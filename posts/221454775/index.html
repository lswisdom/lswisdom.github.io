<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>JDK1.8 HashMap源码简单讲解 | Hexo</title>
  <meta name="description" content="JDK1.8 HashMap源码简单讲解1.成员常量类1.1  序列化版本号1private static final long serialVersionUID &#x3D; 362498820763181265L;    1.2 集合的初始容量12345&#x2F;** * The default initial capacity - MUST be a power of two. * 默认容量是16,必须是2的">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK1.8 HashMap源码简单讲解">
<meta property="og:url" content="https://lswisdom.github.io/posts/221454775/index.html">
<meta property="og:site_name" content="LsWisdom的博客">
<meta property="og:description" content="JDK1.8 HashMap源码简单讲解1.成员常量类1.1  序列化版本号1private static final long serialVersionUID &#x3D; 362498820763181265L;    1.2 集合的初始容量12345&#x2F;** * The default initial capacity - MUST be a power of two. * 默认容量是16,必须是2的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png?versionId=CAEQGxiBgIDF.fqw2hciIGMxZjNiNzhmMDM0NzQyZjQ5OGE0MWY2OGM5MTg5MzZi">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/Jdk1.8%E6%9C%AA%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B9%8B%E5%89%8D%E7%9A%84%E5%BD%A2%E6%80%81.png?versionId=CAEQGxiBgMDP.fqw2hciIDQzYmNkYTQzZTNhMDQ4MmZhZDQyNjI1ZjZjYjJiOGRm">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/TreeNode%E8%8A%82%E7%82%B9.png?versionId=CAEQGxiBgIDP.fqw2hciIDgyYmM3ZWZlNzAyYTRiZTliZWU0YTdiZWU5NzNhMGYy">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIC2.fqw2hciIGI4M2M2ZTIzOTYzYTQ3ZjI4YzY5YjBhNzBjOGNhNDU5">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.png?versionId=CAEQGxiBgMDZ.fqw2hciIGNkYzZjZTM0NzAzMzQxMDM4MTUxN2MzY2RjN2E1NmRl">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/jdk1.7%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png?versionId=CAEQGxiBgMDS.fqw2hciIGNhM2Y4YTk2ZDZiMjRhODhhYzQ2NDAyNWUyYWM5NGQ4">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/hashmap%E7%B1%BB%E5%9B%BE.png?versionId=CAEQGxiBgIDQ.fqw2hciIGU2NjViYzk4Y2IwMjRmZmJiZTQ1MjJhMDZiZjcyMjE5">
<meta property="article:published_time" content="2021-08-16T00:00:00.000Z">
<meta property="article:modified_time" content="2022-10-30T03:03:16.006Z">
<meta property="article:author" content="ls">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png?versionId=CAEQGxiBgIDF.fqw2hciIGMxZjNiNzhmMDM0NzQyZjQ5OGE0MWY2OGM5MTg5MzZi">
  <!-- Canonical links -->
  <link rel="canonical" href="https://lswisdom.github.io/posts/221454775/index.html">
  
    <link rel="alternate" href="/atom.xml" title="LsWisdom的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/timg.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm"></h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">LsWisdom Blog</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lswisdom" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>知识的碰撞能擦出不一样的火花!<br/> 欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">搜索引擎</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/">缓存中间件</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Es%E5%AD%A6%E4%B9%A0/" style="font-size: 13.67px;">Es学习</a> <a href="/tags/Java%E9%9B%86%E5%90%88/" style="font-size: 13.67px;">Java集合</a> <a href="/tags/Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" style="font-size: 13.67px;">Linux环境安装</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/db/" style="font-size: 13.33px;">db</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/kubernetes/" style="font-size: 14px;">kubernetes</a> <a href="/tags/vue/" style="font-size: 13px;">vue</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 13px;">线程</a> <a href="/tags/%E8%AF%81%E4%B9%A6/" style="font-size: 13.33px;">证书</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/7088814413/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/7088814413/" class="title">Docker部署Gitlab</a>
              </p>
              <p class="item-date">
                <time datetime="2023-03-29T07:01:26.000Z" itemprop="datePublished">2023-03-29</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/3647423787/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/3647423787/" class="title">rancher安装postgresql数据库</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-31T15:09:47.000Z" itemprop="datePublished">2022-10-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/879586788/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/879586788/" class="title">Kubernetes集群公共服务</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-29T10:06:57.000Z" itemprop="datePublished">2022-10-29</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/859516788/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/859516788/" class="title">Rancher安装使用</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-29T10:06:57.000Z" itemprop="datePublished">2022-10-29</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/879516718/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/879516718/" class="title">Rancher安装Mysql</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-29T10:06:57.000Z" itemprop="datePublished">2022-10-29</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jdk18-hashmap%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">JDK1.8 HashMap源码简单讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1.成员常量类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%BA%8F%E5%88%97%E5%8C%96%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1  序列化版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 集合的初始容量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121-%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82%E5%A6%82%E6%9E%9C%E8%BE%93%E5%85%A5%E5%80%BC%E4%B8%8D%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AF%94%E5%A6%8217%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 问题：为什么必须是2的n次幂?如果输入值不是2的幂,比如17会怎么样?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E8%80%8C%E6%98%AF%E9%80%9A%E8%BF%87%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 为什么不直接进行取余运算，而是通过位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123-%E5%A6%82%E6%9E%9C%E5%88%9D%E5%A7%8Bhashmap%E7%9A%84%E5%AE%B9%E9%87%8F%E4%B8%8D%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82%E4%BC%9A%E5%81%9A%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 如果初始hashmap的容量不是2的n次幂，会做哪些操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E9%A6%96%E5%85%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9cap%E5%81%9A%E5%87%8F1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">a.首先,为什么要对cap做减1操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 负载因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%88%E5%80%BC8"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 链表转红黑树的阈值8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981-%E4%B8%BA%E4%BB%80%E4%B9%88map%E6%A1%B6%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E8%A6%81%E8%B6%85%E8%BF%878%E6%89%8D%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">问题1： 为什么Map桶中的节点个数要超过8才转红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%E5%9F%BA%E4%BA%8Ejdk18hashmap%E5%BC%95%E5%85%A5%E4%BA%86%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%BC%80%E5%A7%8B%E4%B8%8D%E6%8C%89%E7%85%A7%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%98%E5%82%A8-%E8%A6%81%E7%AD%89%E5%88%B0%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E8%E6%89%8D%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">问题2：基于JDK1.8,hashmap引入了红黑树，为什么一开始不按照红黑树存储。要等到链表长度大于8才转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%BA%A2%E9%BB%91%E6%A0%91%E9%80%80%E5%8C%96%E4%B8%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%88%E5%80%BC"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 红黑树退化为链表的阈值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E6%97%B6%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 链表转红黑树时，数组的长度最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-table-%E7%94%A8%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 table 用来初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%AD%98%E6%94%BE%E5%85%83%E7%B4%A0%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.8.</span> <span class="toc-text">1.8 存放元素缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-hashmap%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.9.</span> <span class="toc-text">1.9 HashMap元素的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95hashmap%E7%9A%84%E4%BF%AE%E6%94%B9%E6%AC%A1%E6%95%B0"><span class="toc-number">1.1.10.</span> <span class="toc-text">1.10 用来记录HashMap的修改次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E8%A6%81%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%B0%8F%E5%80%BC%E5%AE%B9%E9%87%8F%E8%B4%9F%E8%BD%BD%E7%B3%BB%E6%95%B0"><span class="toc-number">1.1.11.</span> <span class="toc-text">1.11 要调整大小的下一个大小值（容量*负载系数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89"><span class="toc-number">1.1.12.</span> <span class="toc-text">1.12 解决hash冲突的常用方法有</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2hashmap%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2.hashmap的方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-hash%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95-hash"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 hash值计算方法 hash()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-hashmap%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 hashmap的put()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-treeifybin"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.5 TreeifyBin()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-treeify"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.6 Treeify()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%BA%A2%E9%BB%91%E6%A0%91%E8%87%AA%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.7 红黑树自平衡操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#271balanceinsertion"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.71balanceInsertion()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#272-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8Brotateleft"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.72 红黑树左旋rotateLeft</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#273-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8Brotateright"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.73 红黑树右旋rotateRight</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%89%A9%E5%AE%B9resize-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.8 扩容resize() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#241-hashmap%E6%89%A9%E5%AE%B9%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.41 hashmap扩容的条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#242-%E6%89%A9%E5%AE%B9%E5%90%8E%E7%9A%84%E5%85%83%E7%B4%A0%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.42 扩容后的元素怎么存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#243-hashmap%E5%AE%B9%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.4.3 hashmap容量初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#244-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Bhashmap%E9%80%A0%E6%88%90cpu100%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">2.4.4 多线程下hashmap造成cpu100%的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#245-hashmap%E7%9A%84size%E4%B8%8D%E5%87%86%E7%A1%AE%E9%80%A0%E6%88%90%E7%9A%84%E8%AF%A1%E5%BC%82%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">2.4.5 hashmap的size不准确造成的诡异问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3hashtable-hashmap-treemap%E4%B8%8D%E5%90%8C"><span class="toc-number">1.3.</span> <span class="toc-text">3.HashTable、HashMap、TreeMap不同</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-JDK/JDK1.8 HashMap源码讲解" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      JDK1.8 HashMap源码简单讲解
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/221454775/" class="article-date">
	  <time datetime="2021-08-16T00:00:00.000Z" itemprop="datePublished">2021-08-16</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Java%E9%9B%86%E5%90%88/" rel="tag">Java集合</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/221454775/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 11.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 48(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="jdk18-hashmap源码简单讲解"><a href="#JDK1-8-HashMap源码简单讲解" class="headerlink" title="JDK1.8 HashMap源码简单讲解"></a>JDK1.8 HashMap源码简单讲解</h1><h2 id="1成员常量类"><a href="#1-成员常量类" class="headerlink" title="1.成员常量类"></a>1.成员常量类</h2><h3 id="11-序列化版本号"><a href="#1-1-序列化版本号" class="headerlink" title="1.1  序列化版本号"></a>1.1  序列化版本号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure>



<h3 id="12-集合的初始容量"><a href="#1-2-集合的初始容量" class="headerlink" title="1.2 集合的初始容量"></a>1.2 集合的初始容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> * 默认容量是16,必须是2的n的n次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>



<h4 id="121-问题为什么必须是2的n次幂如果输入值不是2的幂比如17会怎么样"><a href="#1-2-1-问题：为什么必须是2的n次幂-如果输入值不是2的幂-比如17会怎么样" class="headerlink" title="1.2.1 问题：为什么必须是2的n次幂?如果输入值不是2的幂,比如17会怎么样?"></a>1.2.1 问题：为什么必须是2的n次幂?如果输入值不是2的幂,比如17会怎么样?</h4><p>这样做是为了减少hash碰撞的次数， 2的n次方实际就是1后面n个0，2的n次方减1二进制表示时实际就是n个1;</p>
<p><strong>按位与运算</strong> : 相同的二进制数位上,都是1的时候，结果为1,否则为零。</p>
<p><strong>按位或运算</strong> ： 相同的二进制数位上,都是0的时候，结果为0,否则为1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">hash计算存放位置的时候,是通过hash&amp;(length-<span class="number">1</span>)</span><br><span class="line">例如<span class="number">1</span>：</span><br><span class="line">hash值如果为<span class="number">3</span>,hashmap默认容量为<span class="number">16</span>  ,即 <span class="number">3</span> &amp; (<span class="number">16</span>-<span class="number">1</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span>    <span class="number">3</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span>    <span class="number">15</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span>    <span class="number">3</span>  索引值为<span class="number">3</span></span><br><span class="line"></span><br><span class="line">例如<span class="number">2</span>：</span><br><span class="line">hash值如果为<span class="number">5</span>,hashmap默认容量为<span class="number">16</span>  ,即 <span class="number">5</span> &amp; (<span class="number">16</span>-<span class="number">1</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span>    <span class="number">5</span></span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span>    <span class="number">15</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span>    <span class="number">5</span>  索引值为<span class="number">5</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line">如果不是<span class="number">2</span>的n次幂</span><br><span class="line">hash值如果为<span class="number">3</span>,hashmap容量设置为<span class="number">17</span>  ,即 <span class="number">3</span> &amp; (<span class="number">17</span>-<span class="number">1</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span>    <span class="number">3</span>  </span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span>    <span class="number">16</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>    <span class="number">0</span> 索引位置为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">hash值如果为<span class="number">7</span>,hashmap容量设置为<span class="number">17</span>  ,即 <span class="number">7</span> &amp; (<span class="number">17</span>-<span class="number">1</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">0111</span>    <span class="number">7</span></span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span>    <span class="number">16</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>    <span class="number">0</span> 索引位置为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">hash值如果为<span class="number">9</span>,hashmap容量设置为<span class="number">17</span>  ,即 <span class="number">7</span> &amp; (<span class="number">17</span>-<span class="number">1</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">1001</span>    <span class="number">9</span></span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span>    <span class="number">16</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>    <span class="number">0</span> 索引位置为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>​            1.由上面可以看出，当我们根据key的hash确定其在数组的位置时， 如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突,毕竟hash冲突越大, 代<br>表数组中一个链的长度越大，这样的话会降低hashmap的性能</p>
<h4 id="122-为什么不直接进行取余运算而是通过位运算"><a href="#1-2-2-为什么不直接进行取余运算，而是通过位运算" class="headerlink" title="1.2.2 为什么不直接进行取余运算，而是通过位运算"></a>1.2.2 为什么不直接进行取余运算，而是通过位运算</h4><p>在计算中，数据是采用0101存储的，位运算的效率远比取模%高，所以，使用位运算代替取余操作，来确定元素的存储问题。当前两种方式，得到的结果都是一样的，只是效率不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash &amp; (length-1)&#x3D;&#x3D; hash % length</span><br></pre></td></tr></table></figure>



<h4 id="123-如果初始hashmap的容量不是2的n次幂会做哪些操作"><a href="#1-2-3-如果初始hashmap的容量不是2的n次幂，会做哪些操作" class="headerlink" title="1.2.3 如果初始hashmap的容量不是2的n次幂，会做哪些操作"></a>1.2.3 如果初始hashmap的容量不是2的n次幂，会做哪些操作</h4><p>如果创建HashMap对象时，输入的数组长度是17,不是2的幂，HashMap通过移位运算和或运算得到<br>的肯定是2的幂次数,并且是离那个数最近的数字。例如如果容量是17，初始化容量就是返回32</p>
<p>下述源码就是初始化时指定大小和负载因子</p>
<p>jdk1.8源码操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">  * capacity and load factor.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">  *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果初始容量小于0,抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     <span class="comment">// 如果初始容量大于最大容量2^30,复制为最大容量。防止溢出</span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="comment">// 负载因子小于0,报错提示</span></span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// threshold hashmap扩容阈值,注意这个值会发生变化。</span></span><br><span class="line">     <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回给定目标容量的2次幂大小。  </span></span><br><span class="line"><span class="comment">  * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">     n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">     <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>上述代码第二个方法，就是操作</p>
<p>说明:<br>            由此可以看到，当在实例化HashMap实例时， 如果给定了initialCapacity(假设是17),由于HashMap的capacity必须都是2的幂次方，因此这个方法用于找到大于等于initialCapacity(假设是17)的最小的2的幂(initialCapacity如果就是2的幂次方，比如说16，则返回的还是这个数)。</p>
<p><strong>下面分析这段源码算法:</strong></p>
<h5 id="a首先为什么要对cap做减1操作"><a href="#a-首先-为什么要对cap做减1操作" class="headerlink" title="a.首先,为什么要对cap做减1操作"></a>a.首先,为什么要对cap做减1操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n &#x3D; cap - 1</span><br></pre></td></tr></table></figure>

<p>如果cap已经是2的幂，此时又没有执行这个减1操作, 则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。</p>
<p><strong>注意：</strong></p>
<p><strong>按位与运算</strong> : 相同的二进制数位上,都是1的时候，结果为1,否则为零。</p>
<p><strong>按位或运算</strong> ： 相同的二进制数位上,都是0的时候，结果为0,否则为1。</p>
<p>b.下面看看这几个无符号右移操作是干什么的  1是负数  0正数</p>
<p>​       <strong>第一种情况，容量传递的是0</strong></p>
<p>​            如果n这时为0了(经过了cap-1之后) , 则经过后面的几次无符号右移依然是0,最后返回的capacity是1 </p>
<p>​        **第二种情况，n不等于0 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">HashMap &lt;String,Object&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">17</span>);</span><br><span class="line">cap = <span class="number">17</span></span><br><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span> = <span class="number">16</span>;</span><br><span class="line">第一次无符号右移一位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">0000</span>    n=<span class="number">16</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">1000</span>    n &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1000</span>    <span class="number">24</span> ===&gt;n</span><br><span class="line"></span><br><span class="line">第二次无符号右移<span class="number">2</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1000</span>    n=<span class="number">24</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0110</span>    n &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1110</span>    n = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">第三次无符号右移<span class="number">4</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1110</span>    n = <span class="number">30</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0001</span>    n &gt;&gt;&gt; <span class="number">4</span></span><br><span class="line">------------------------------------------------------ </span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">第四次无符号右移<span class="number">8</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>    n &gt;&gt;&gt; <span class="number">8</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line"></span><br><span class="line">第五次无符号右移<span class="number">16</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>    n &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line">执行最后一行代码操作,n&gt;<span class="number">0</span>且小于最大容量,返回<span class="number">31</span>+<span class="number">1</span> = <span class="number">32</span></span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<p>Hashmap最大容量的移动位置操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">2</span>^<span class="number">30</span></span><br><span class="line"><span class="keyword">int</span> n = cap-<span class="number">1</span>;</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    n=<span class="number">2</span>^<span class="number">30</span> -<span class="number">1</span>   </span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    n &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    n&gt;&gt;&gt;<span class="number">2</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">最后得到的值一定为</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line">加一操作后为</span><br><span class="line"><span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>    <span class="number">2</span>^<span class="number">30</span></span><br></pre></td></tr></table></figure>



<p>** 总结** ：如果容量大于MAXIMUM_CAPACITY  则取最大容量。不到2^30 的容量，通过移位操作后，会得到大于值的最小2的幂。如果当前值就是2的幂次方，返回当前值</p>
<h3 id="13-负载因子"><a href="#1-3-负载因子" class="headerlink" title="1.3 负载因子"></a>1.3 负载因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>对于负载因子，如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的（逼哥讲过大量研究得出）。如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。如果使用太小的负载因子，可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</p>
<ul>
<li><p>loadFactor越趋近于1,那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加。</p>
</li>
<li><p>loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
</li>
</ul>
<p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一-直没有存储数据。加载因子尽可能小一些。<br>举例:<br>1.加载因子是0.5。那么16 *  0.5 = 8  如果数组中满8个空间就扩容，这样会造成数组利用率太低了。<br>2.加载因子是0.9。那么16 *  0.9=14  如果数组中满14个空间就扩容，hash碰撞次数大大增加，那么这样就会导致链表有点多了。导致查找元素效率低。</p>
<p>所以既兼顾<strong>数组利用率</strong>又考虑<strong>链表长度不要太多</strong>，经过逼哥  大量测试0.75是最佳方案。</p>
<h3 id="14-链表转红黑树的阈值8"><a href="#1-4-链表转红黑树的阈值8" class="headerlink" title="1.4 链表转红黑树的阈值8"></a>1.4 链表转红黑树的阈值8</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>



<h4 id="问题1-为什么map桶中的节点个数要超过8才转红黑树"><a href="#问题1：-为什么Map桶中的节点个数要超过8才转红黑树" class="headerlink" title="问题1： 为什么Map桶中的节点个数要超过8才转红黑树"></a>问题1： 为什么Map桶中的节点个数要超过8才转红黑树</h4><p>源码注释中有这么一段描述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    * Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">     * use them only when bins contain enough nodes to warrant use</span><br><span class="line">     * (see TREEIFY_THRESHOLD). <span class="function">And when they become too <span class="title">small</span> <span class="params">(due to</span></span></span><br><span class="line"><span class="function"><span class="params">     * removal or resizing)</span> they are converted back to plain bins.  In</span></span><br><span class="line"><span class="function">     * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="function">     * rarely used.  Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="function">     * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="function">     * <span class="params">(http://en.wikipedia.org/wiki/Poisson_distribution)</span> with a</span></span><br><span class="line"><span class="function">     * parameter of about 0.5 on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing</span></span><br><span class="line"><span class="function">     * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="function">     * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="function">     * occurrences of list size k <span class="title">are</span> <span class="params">(exp(-<span class="number">0.5</span>)</span> * <span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span> /</span></span><br><span class="line"><span class="function">     * <span class="title">factorial</span><span class="params">(k)</span>). The first values are:</span></span><br><span class="line"><span class="function">因为树节点的大小大约是普通节点的两倍，所以我们只在bin包含足够的节点时才使用树节点<span class="params">(参见</span></span></span><br><span class="line"><span class="function"><span class="params">TREEIFY_THRESHOLD)</span>。当它们变得太小<span class="params">(由于删除或调整大小)</span>时，就会被转换回普通的桶。在使用分布良好的用户</span></span><br><span class="line"><span class="function">hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</span></span><br><span class="line"><span class="function"><span class="params">(http://en.wikipedia. org/wiki/Poisson. distr ibution)</span>,默认调整阈值为0.75,平均参数约为0.5,尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是<span class="params">(exp(-<span class="number">0.5</span>)</span>*<span class="title">pow</span><span class="params">(<span class="number">0.5</span>，k)</span>/<span class="title">factorial</span><span class="params">(k)</span>).</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     *</span></span><br><span class="line"><span class="function">     * 0:    0.60653066</span></span><br><span class="line"><span class="function">     * 1:    0.30326533</span></span><br><span class="line"><span class="function">     * 2:    0.07581633</span></span><br><span class="line"><span class="function">     * 3:    0.01263606</span></span><br><span class="line"><span class="function">     * 4:    0.00157952</span></span><br><span class="line"><span class="function">     * 5:    0.00015795</span></span><br><span class="line"><span class="function">     * 6:    0.00001316</span></span><br><span class="line"><span class="function">     * 7:    0.00000094</span></span><br><span class="line"><span class="function">     * 8:    0.00000006</span></span><br><span class="line"><span class="function">     * more: less than 1 in ten million</span></span><br><span class="line"><span class="function">     *</span></span><br><span class="line"><span class="function">     * The root of a tree bin is normally its first node.  However,</span></span><br><span class="line"><span class="function">     * <span class="title">sometimes</span> <span class="params">(currently only upon Iterator.remove)</span>, the root might</span></span><br><span class="line"><span class="function">     * be elsewhere, but can be recovered following parent links</span></span><br><span class="line"><span class="function">     * <span class="params">(method TreeNode.root()</span>).</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1.TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes,而是否足够<br>多就是由TREEIFY_THRESHOLD（8）的值决定的。当bin中节点数变少时， 又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8(桶的数量要大于64)就转成红黑树，当长度降到6就转成普通bin.这样就解释了为什么不是一开始就将其转换为TreeNodes, 而是需要一定节点数才转为TreeNodes, 说白了就是权衡，空间和时间的权衡。</p>
<p>2.当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过<strong>理想情况</strong>下随机hashCode算法下所有bin中节点的分布频率会遵循<strong>泊松分布</strong>，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006. 几乎是不<br>可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。</p>
<p>也就是说:选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p>
<p>3.泊松分布</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png?versionId=CAEQGxiBgIDF.fqw2hciIGMxZjNiNzhmMDM0NzQyZjQ5OGE0MWY2OGM5MTg5MzZi"></p>
<p>图片原文链接：</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html</a></p>
<h4 id="问题2基于jdk18hashmap引入了红黑树为什么一开始不按照红黑树存储-要等到链表长度大于8才转换"><a href="#问题2：基于JDK1-8-hashmap引入了红黑树，为什么一开始不按照红黑树存储。要等到链表长度大于8才转换" class="headerlink" title="问题2：基于JDK1.8,hashmap引入了红黑树，为什么一开始不按照红黑树存储。要等到链表长度大于8才转换"></a>问题2：基于JDK1.8,hashmap引入了红黑树，为什么一开始不按照红黑树存储。要等到链表长度大于8才转换</h4><p>​        JDK 1.8以前HashMap的实现是数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表， 这个时候HashMap就相当于一<br>个单链表，假如单链表有n个元素,遍历的时间复杂度就是O(n),完全失去了它的优势。针对这种情况，JDK 1.8<br>中引入了红黑树(查找时间复杂度为O(logn))来优化这个问题。当链表长度很小的时候， 即使遍历,速度也非<br>常快,但是当链表长度不断变长，肯定会对查询性能有一定的影响， 所以才需要转成树。</p>
<p>2.TreeNodes占用空间是普通Nodes的两倍，当元素较少时，增加多余的开销</p>
<h3 id="15-红黑树退化为链表的阈值"><a href="#1-5-红黑树退化为链表的阈值" class="headerlink" title="1.5 红黑树退化为链表的阈值"></a>1.5 红黑树退化为链表的阈值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">  * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">  * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">  	当桶(bucket) 上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>



<h3 id="16-链表转红黑树时数组的长度最小值"><a href="#1-6-链表转红黑树时，数组的长度最小值" class="headerlink" title="1.6 链表转红黑树时，数组的长度最小值"></a>1.6 链表转红黑树时，数组的长度最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">   * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">   * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">   * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>



<h3 id="17-table-用来初始化"><a href="#1-7-table-用来初始化" class="headerlink" title="1.7 table 用来初始化"></a>1.7 table 用来初始化</h3><p>table必须是2的幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。 都实现了一样的接口:Map.Entry&lt;K,V&gt;.负责存储键值对数据的。在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，tabl e的初始化被推<br>迟到了put方法中</p>
<h3 id="18-存放元素缓存"><a href="#1-8-存放元素缓存" class="headerlink" title="1.8 存放元素缓存"></a>1.8 存放元素缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">  * for keySet() and values().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>



<h3 id="19-hashmap元素的个数"><a href="#1-9-HashMap元素的个数" class="headerlink" title="1.9 HashMap元素的个数"></a>1.9 HashMap元素的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>



<h3 id="110-用来记录hashmap的修改次数"><a href="#1-10-用来记录HashMap的修改次数" class="headerlink" title="1.10 用来记录HashMap的修改次数"></a>1.10 用来记录HashMap的修改次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">    结构修改是指改变HashMap中的映射数量或修改其内部结构(例如，rehash)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>



<h3 id="111-要调整大小的下一个大小值容量负载系数"><a href="#1-11-要调整大小的下一个大小值（容量-负载系数）" class="headerlink" title="1.11 要调整大小的下一个大小值（容量*负载系数）"></a>1.11 要调整大小的下一个大小值（容量*负载系数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> * 要调整大小的下一个大小值（容量*负载系数）。 数组长度唱过临界值时会进行扩容操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>





<h3 id="112-解决hash冲突的常用方法有"><a href="#1-12-解决hash冲突的常用方法有" class="headerlink" title="1.12 解决hash冲突的常用方法有"></a>1.12 解决hash冲突的常用方法有</h3><p> <strong>1.开放定址法</strong><br>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>
<p><strong>2.再哈希法</strong><br>这种方法是同时构造多个不同的哈希函数：<br>Hi=RH1（key）  i=1，2，…，k<br>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<p><strong>3.链地址法</strong><br>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p>hashmap解决hash冲突就是采用链地址法</p>
<p><strong>4.建立公共溢出区</strong><br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。  </p>
<h2 id="2hashmap的方法介绍"><a href="#2-hashmap的方法介绍" class="headerlink" title="2.hashmap的方法介绍"></a>2.hashmap的方法介绍</h2><p><strong>Node节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     V value;</span><br><span class="line">     Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">     Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hash = hash;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>TreeNode节点</strong>部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">  * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">  * linked node.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">     TreeNode&lt;K,V&gt; left;</span><br><span class="line">     TreeNode&lt;K,V&gt; right;</span><br><span class="line">     TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">     <span class="keyword">boolean</span> red;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> r;</span><br><span class="line">             r = p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h3 id="21-hash值计算方法-hash"><a href="#2-1-hash值计算方法-hash" class="headerlink" title="2.1 hash值计算方法 hash()"></a>2.1 hash值计算方法 hash()</h3><p>jdk1.8 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算hash值的方法</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> 	计算 key.hashCode() 并将散列的较高位（异或）传播到较低位。由于该表使用二次幂掩码，因此仅在当前		掩码之上位变化的散列集将始终发生冲突。 （众所周知的例子是在小表中保存连续整数的浮点键集。）所以我们应用一个变换，将高位的影响向下传播。位扩展的速度、效用和质量之间存在折衷。因为许多常见的散列集已经合理分布（因此不会从扩展中受益），并且因为我们使用树来处理 bin 中的大量冲突，所以我们只是以最便宜的方式对一些移位的位进行异或以减少系统损失，以及合并最高位的影响，否则由于表边界而永远不会在索引计算中使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p>
<p>可以看到当key等于null的时候也是有哈希值的，返回的是0.</p>
<p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的<br>hash值。计算过程如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure>

<p>这里其实就是把得到的hashcode转化为32位二进制，然后他的高16位和低16位做了一个异或的操作</p>
<p>举个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&amp; (按位与运算) : 运算规则:相同的二进制数位上,都是<span class="number">1</span>的时候，结果为<span class="number">1</span>,否则为零。</span><br><span class="line">^ (按位异或运算) :运算规则:相同的二进制数位上，数字相同，结果为<span class="number">0</span>，不同为<span class="number">1.</span></span><br><span class="line">代码中通过这个hash &amp; (n-<span class="number">1</span>) 得到存储元素的位置</span><br><span class="line">p = tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br><span class="line"></span><br><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">假设这里的h = key.hashCode()得到的值为</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span>    h</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    h &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>   按位异或运算后得到的hash值</span><br><span class="line"></span><br><span class="line">此时数据长度n假设为默认的<span class="number">16</span>,那么这个key存放在table中位置为i = (n - <span class="number">1</span>) &amp; hash</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>      hash</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>      n-<span class="number">1</span> <span class="number">15</span>   &amp;运算</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>     索引位置为<span class="number">0</span> </span><br><span class="line"></span><br><span class="line">在存储一个key,假设key的hashcode高位变化较大</span><br><span class="line"><span class="number">1000</span> <span class="number">1000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>      hash值</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>      n-<span class="number">1</span> <span class="number">15</span>   &amp;运算</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>      索引位置为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>如果当n的值,即数组长度很小时，假设是默认的16的话,这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小,这样就很容易造成哈希冲突了，所以这里把高低位都利用起来,从而解决了这个问题。也是一种为了降低hash冲突的优化手段</p>
<p>​           为什么这里需要将高位数据移位到低位进行异或运算呢？这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</p>
<h3 id="22-hashmap的put方法"><a href="#2-2-hashmap的put-方法" class="headerlink" title="2.2 hashmap的put()方法"></a>2.2 hashmap的put()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value  如果为true表示不更改现有的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode. 表示table为创建状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p表示当前的节点。n表示表的长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// hashmap的table表的初始化操作,是在这里进行的。第一次执行的时候,会先在这里进行初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 通过上述hash()方法得到hash值和数组长度进行按位与运算，得到元素的存储位置，如果table表的位置为空，就直接进行存储操作</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 产生了hash碰撞,走下述代码</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 这里的p的值是上面p = tab[i = (n - 1) &amp; hash ,if语句体虽然没有执行，但是这一段代码是否执行的,判断hash值和key值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断当前table中的p节点是不是树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 遍历链表的,取下一个位置存放新增的元素,这里采用的是尾插法，a.横竖都要遍历链表的长度是否大于树化的阈值，所以遍历的过程中，就直接插入元素了b.可能的因素就是遍历的过程中要比较key值是否相同，和jdk1.7有些不同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果下一个位置为空,就直接连接在链表后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表的长度大于8个时,就进行链表转红黑树的操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表的下一个元素不为空,比较hash值和key值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key值存在,就替换value值。新插入的元素的value值,替换原来这个key的value值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">     <span class="comment">// hashmap的键值对个数大于扩容的阈值,就进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如图示：桶长度（bucket) 为8的数组</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/Jdk1.8%E6%9C%AA%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B9%8B%E5%89%8D%E7%9A%84%E5%BD%A2%E6%80%81.png?versionId=CAEQGxiBgMDP.fqw2hciIDQzYmNkYTQzZTNhMDQ4MmZhZDQyNjI1ZjZjYjJiOGRm"></p>
<h3 id="25-treeifybin"><a href="#2-5-TreeifyBin" class="headerlink" title="2.5 TreeifyBin()"></a>2.5 TreeifyBin()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> 	替换指定哈希表的索引桶中所有的连接节点，除非表太小，否则将修改大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/* 如果元素数组为空 或者 数组长度小于 树结构化的最小阈值（MIN_TREEIFY_CAPACITY=64） ,就进行扩容操作.对于这个值可以理解为：如果元素数组长度小于这个值，没有必要去进行结构转换.目的是</span></span><br><span class="line"><span class="comment">       如果数组很小,那么转红黑树,遍历效率要低一些，这时进行扩容操作，重新计算哈希值，链表的长度有可能就变短了。数据会放入到数组中，这样相对来说效率会高一些</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">        <span class="comment">//如果元素数组长度已经大于等于了 MIN_TREEIFY_CAPACITY，那么就有必要进行结构转换了</span></span><br><span class="line">        <span class="comment">// 根据hash值和数组长度进行取模运算后，得到链表的首节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//定义几个变量，hd代表头节点，tl代表尾节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">//先把e节点转成TreeNode类型，并赋值给p</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="comment">//如果尾节点tl为空，则说明还没有根节点，试想下，这时元素数目都超过8个了，还能没有尾节点么，所以没有尾节点只能说明还没设置根节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">//设置根节点，把p赋值给根节点hd</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//把tl设置为p的前一节点</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                 <span class="comment">//把p设置为tl的后继节点，这两步其实就是我指向你，你指向我的关系，为了形成双向链表</span></span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把首节点设置成p后，把p赋值给尾节点tl，然后会再取链表的下一个节点，转成TreeNode类型后再赋值给p，如此循环</span></span><br><span class="line">            tl = p;</span><br><span class="line">              <span class="comment">//取下一个节点，直到下一个节点为空，也就代表这链表遍历好了</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         <span class="comment">//用新生成的双向链表替代旧的单向链表，其实就是把这个数组对应的位置重新赋值成新双向链表的首节点</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bin 的数量大于 TREEIFY_THRESHOLD 时：如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</p>
<p>本质上这是个<strong>安全问题</strong>。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。</p>
<p>最后一行才是转红黑树的操作</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/TreeNode%E8%8A%82%E7%82%B9.png?versionId=CAEQGxiBgIDP.fqw2hciIDgyYmM3ZWZlNzAyYTRiZTliZWU0YTdiZWU5NzNhMGYy"></p>
<h3 id="26-treeify"><a href="#2-6-Treeify" class="headerlink" title="2.6 Treeify()"></a>2.6 Treeify()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//  遍历链表，x指向当前节点、next指向下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果根节点为空，则把当前节点当做根节点。根据红黑树性质，根节点一定为黑色。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根节点已经存在的情况</span></span><br><span class="line">            <span class="comment">// 取得当前节点和当前节点的hash值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 从根节点遍历。这一步主要就是为了，判断当前节点应该在树的左侧还是右侧</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;  <span class="comment">// dir代表方向  ph表示树节点的hash值。即TreeNodehash值</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 如果当前树节点hash值 大于 当前链表节点的hash值</span></span><br><span class="line">                    dir = -<span class="number">1</span>;  <span class="comment">//  标识当前链表节点会放到当前树节点的左侧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                <span class="comment">// 保存当前树节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// 判断如果dir&lt;=0 说明当前节点的hash值小于当前树节点的hash值。需要把当前节点放置在当前树节点的左侧</span></span><br><span class="line">                <span class="comment">// 判断如果dir&gt;0 说明当前节点的hash值大于当前树节点的hash值。 需要把当前节点放置在当前树节点的右侧</span></span><br><span class="line">                <span class="comment">// p的左右节点存在不为空的情况,p节点就是当前遍历的树节点，说明该节点还有子节点。继续循环查找当前节点x的应该在哪里爸爸节点下面插入元素</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 元素插入之后，需要进行红黑树的自平衡操作,重新确定根节点的值</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-红黑树自平衡操作"><a href="#2-7-红黑树自平衡操作" class="headerlink" title="2.7 红黑树自平衡操作"></a>2.7 红黑树自平衡操作</h3><h4 id="271balanceinsertion"><a href="#2-71balanceInsertion" class="headerlink" title="2.71balanceInsertion()"></a>2.71balanceInsertion()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入节点是黑色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// xp为父节点  xpp：为爷爷节点   xxpl是爷爷的左节点  xppr：是爷爷节点的右节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">// 当前节点的父节点不存在,当前节点就是根节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父节点是黑色。当前节点可以直接插入,所以父节点就是根节点。   父节点如果是黑色，则爷爷节点一定不存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 如果父节点是爷爷节点的左节点    </span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">// 如果爷爷节点的右节点不为空 同时是红节点</span></span><br><span class="line">            <span class="comment">//  a.将爸爸和叔叔节点变成黑色  b.将爷爷节点变成红色  c.并且将爷爷节点当成当前节点,进行下一轮的处理</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果父节点是爷爷节点的左节点   插入节点时爷爷节点的右节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">// a.已爸爸为节点进行一次左旋操作,得到(LL双红的情况 4.2.1) 然后指定爸爸节点为当前节点,执行下一轮的操作</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a.将爸爸节点染成黑色 b.将爷爷染成红色 c.然后已爷爷节点进行右旋操作</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 叔叔节点不为空,同事叔叔节点为红色</span></span><br><span class="line">            <span class="comment">// a.将爸爸和叔叔节点变成黑色  b.将爷爷节点变成红色  c.并且将爷爷节点当成当前节点,进行下一轮的处理</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 插入节点为其父节点的左子节点(RL情况) a.以爸爸节点进行一次右旋,得到RR双红的场景( RR情况 4.3.1).然后指定爸爸节点为当前节点,进行下一轮的操作</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    <span class="comment">// 平衡过后,重新定义爷爷节点的变量值</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 插入节点为其父节点的右子节点(RR情况) a.将爸爸染成黑色节点  b.将爷爷染成红色 c.然后已爷爷节点进行左旋操作</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="272-红黑树左旋rotateleft"><a href="#2-72-红黑树左旋rotateLeft" class="headerlink" title="2.72 红黑树左旋rotateLeft"></a>2.72 红黑树左旋rotateLeft</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="273-红黑树右旋rotateright"><a href="#2-73-红黑树右旋rotateRight" class="headerlink" title="2.73 红黑树右旋rotateRight"></a>2.73 红黑树右旋rotateRight</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>转换后的形态大约是</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIC2.fqw2hciIGI4M2M2ZTIzOTYzYTQ3ZjI4YzY5YjBhNzBjOGNhNDU5"></p>
<h3 id="28-扩容resize-方法"><a href="#2-8-扩容resize-方法" class="headerlink" title="2.8 扩容resize() 方法"></a>2.8 扩容resize() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     * 初始化或者扩容表的长度为2倍</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 旧表，第一次执行时，oldTabl为空</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 表的容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 要调整大小的下一个大小值，默认是0</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果扩容前旧表的容量大于阈值，就设置为Integer的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;  <span class="comment">// 如果旧表的长度左移一位还小于表的最大容量，就扩容表的长度为旧表的二倍，域值也为原来的一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;   </span><br><span class="line">            <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 初始化新容器的大小，必须是2的幂，默认是16。表刚创建的时候，会执行到这里</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">// 默认的阈值是12 负载因子0.75* 默认的初始化容量16</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新table表扩容时的的阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">// 假设一个容量为16的节点。newCap的值为16 下一次扩容时，容量为32扩大一倍</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 移动旧表的数据到新表中,移动的扩容中,需要重新的进行hash操作</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 链表节点的处理  head是头节点  tail是尾部节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                         <span class="comment">// 获取当前节点的下一个节点，每一次循环e值会更新</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 第一次slot的节点是头节点也是尾结点</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 下一个节点设置为空</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// slot节点的数+旧表的容量 存储新值</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回扩容后新表的长度</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>依据 resize 源码，不考虑极端情况（容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方），我们可以归纳为：阈值等于（负载因子）x（容量），如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。阈值通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），我前面提到，根据 putVal 中的逻辑，当元素个数超过阈值大小时，则调整 Map 大小。扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</p>
<h4 id="241-hashmap扩容的条件"><a href="#2-41-hashmap扩容的条件" class="headerlink" title="2.41 hashmap扩容的条件"></a>2.41 hashmap扩容的条件</h4><p>1.当HashMap中的元素个数超过 <code>数组长度 * loadFactor(负载因子)</code>时,就会进行数组扩容,扩容为原来的2倍</p>
<p>例如：数组长度默认是16，负载因子默认0.75 ，即当数组中 元素个数大于12的时候，就会进行扩容，数组长度变为32</p>
<p>2.在链表转换红黑树的时候，如果桶的数量不足64.也会进行扩容操作 </p>
<h4 id="242-扩容后的元素怎么存储"><a href="#2-42-扩容后的元素怎么存储" class="headerlink" title="2.42 扩容后的元素怎么存储"></a>2.42 扩容后的元素怎么存储</h4><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素,是非常耗时的。在编写程序中,要尽<br>量避免resize。HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的(n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在<strong>原来的位置，</strong>要么就被分配到**”原位置+旧容量”**这个位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&amp; (按位与运算) : 运算规则:相同的二进制数位上,都是<span class="number">1</span>的时候，结果为<span class="number">1</span>,否则为零。</span><br><span class="line">^ (按位异或运算) :运算规则:相同的二进制数位上，数字相同，结果为<span class="number">0</span>，不同为<span class="number">1.</span></span><br><span class="line">代码中通过这个hash &amp; (n-<span class="number">1</span>) 得到存储元素的位置</span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span>   n = <span class="number">16</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>   n-<span class="number">1</span> = <span class="number">15</span></span><br><span class="line">假设hashcode生成的值为 如下<span class="number">2</span>个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0111</span>   hash(key1)</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0111</span>   hash(key2)    扩容后的hash值,比 扩容前多了个比特位</span><br><span class="line"></span><br><span class="line">计算开始</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span>   n = <span class="number">16</span> 扩容前</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>   n-<span class="number">1</span> = <span class="number">15</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0111</span>   hash(key1)</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span>    hash &amp; (n-<span class="number">1</span>) = <span class="number">7</span> 索引位置为<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span>   n=<span class="number">32</span> 扩容一倍后</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1111</span>   n-<span class="number">1</span> = <span class="number">31</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0111</span>   hash(key2)</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0111</span>   hash &amp; (n-<span class="number">1</span>) = <span class="number">23</span>  索引位置为<span class="number">7</span>+<span class="number">16</span>(旧的数组容量)</span><br></pre></td></tr></table></figure>



<p>结论：计算新的索引，高位是0那么存储到<strong>原来索引</strong>位置，如果高位是1那么存储到<strong>原来索引+旧的数组长度</strong>位置。因此，我们在扩充HashMap的时候，不需要重新计算hash,只需要看看原来的hash值新增的那个bit是1还是0就<br>可以了，是0的话索引没变,是1的话索引变成原索引+oldCap(原位置+旧容量)。正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1是是随机的，在resize的过程中保证 了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数,保证了rehash之后不会出现更严重的hash冲突,均匀的把之前的冲突的节点分散到新的桶中了。</p>
<h4 id="243-hashmap容量初始化"><a href="#2-4-3-hashmap容量初始化" class="headerlink" title="2.4.3 hashmap容量初始化"></a>2.4.3 hashmap容量初始化</h4><p>如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，<br>防止HashMap自动扩容，影响使用效率。</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.png?versionId=CAEQGxiBgMDZ.fqw2hciIGNkYzZjZTM0NzAzMzQxMDM4MTUxN2MzY2RjN2E1NmRl"></p>
<h4 id="244-多线程下hashmap造成cpu100的问题"><a href="#2-4-4-多线程下hashmap造成cpu100-的问题" class="headerlink" title="2.4.4 多线程下hashmap造成cpu100%的问题"></a>2.4.4 多线程下hashmap造成cpu100%的问题</h4><p>hashmap不同于hashtable.他是线程不安全的，当多线程并发扩容时就可能会出现环形引用的问题，从而导致死循环的出现，一直死循环就会导致 CPU 运行 100%，但是Oracle认为这不是错误,是因为Hashmap本身就是线程不安全的。Oracle官网的连接如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;bugs.java.com&#x2F;bugdatabase&#x2F;view_bug.do?bug_id&#x3D;6423457</span><br></pre></td></tr></table></figure>

<p>并提供给了我们，可以替换的为jdk1.5之后的 <code>ConcurrentHashMap</code>   或者使用性能较差的Hashtable 或 synchronizedMap 包装器</p>
<p>java并发包的作者原文评论如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Doug Lea writes:</span><br><span class="line"></span><br><span class="line">&quot;This is a classic symptom of an incorrectly synchronized use of</span><br><span class="line">HashMap. Clearly, the submitters need to use a thread-safe</span><br><span class="line">HashMap. If they upgraded to Java 5, they could just use</span><br><span class="line">ConcurrentHashMap. If they can&#39;t do this yet, they can use</span><br><span class="line">either the pre-JSR166 version, or better, the unofficial backport</span><br><span class="line">as mentioned by Martin. If they can&#39;t do any of these, they can</span><br><span class="line">use Hashtable or synchhronizedMap wrappers, and live with poorer</span><br><span class="line">performance. In any case, it&#39;s not a JDK or JVM bug.&quot;</span><br><span class="line"></span><br><span class="line">I agree that the presence of a corrupted data structure alone</span><br><span class="line">does not indicate a bug in the JDK.</span><br></pre></td></tr></table></figure>



<p>为什么并发的时候，会导出环状呢，简单分析下</p>
<p>这个cpu100%的问题，实际工作中上我也没有遇到过，参考了下网上的文章：</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hao134838/article/details/107220317/">https://blog.csdn.net/hao134838/article/details/107220317/</a></p>
<p>JDK1.7的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// 线程一执行此处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/jdk1.7%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png?versionId=CAEQGxiBgMDS.fqw2hciIGNhM2Y4YTk2ZDZiMjRhODhhYzQ2NDAyNWUyYWM5NGQ4"></p>
<p>假设 HashMap 的默认大小为 2，HashMap 本身中有一个键值 key(5)，我们再使用两个线程：t1 添加 key(3)，t2 添加 key(7)，首先两个线程先把 key(3) 和 key(7) 都添加到 HashMap 中，此时因为 HashMap 的长度不够用了就会进行扩容操作，然后这时线程 t1 在执行到 Entry&lt;K,V&gt; next = e.next 时，此时线程t1中的e节点指向了key(3),然后next指针指向了key(7)。然后让出了cpu的执行权。对于线程t2来说，添加key(7) 的时候，会进行扩容操作，扩容的时候，会再次进行rehash操作，重新计算位置，然后把链表的位置更改为了e节点为key7，他的next指向key3.此时t1线程又重新获取到了cpu的执行权。对于t1线程来说，key(3)指向的是key(7)，由于线程t2把key(7)的下一个指向变成了key(3)，对于t1来说，key(7) 的next就是key(3) .这样就造成key(3)和key(7)的循环引用问题，而死循环就是导致cpu100%的原因</p>
<h4 id="245-hashmap的size不准确造成的诡异问题"><a href="#2-4-5-hashmap的size不准确造成的诡异问题" class="headerlink" title="2.4.5 hashmap的size不准确造成的诡异问题"></a>2.4.5 hashmap的size不准确造成的诡异问题</h4><p>略</p>
<h2 id="3hashtable-hashmap-treemap不同"><a href="#3-HashTable、HashMap、TreeMap不同" class="headerlink" title="3.HashTable、HashMap、TreeMap不同"></a>3.HashTable、HashMap、TreeMap不同</h2><p><strong>Hashtable</strong> 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p>
<p><strong>HashMap</strong> 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选</p>
<p><strong>TreeMap</strong> 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p>
<p>类图如下：</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/hashmap%E7%B1%BB%E5%9B%BE.png?versionId=CAEQGxiBgIDQ.fqw2hciIGU2NjViYzk4Y2IwMjRmZmJiZTQ1MjJhMDZiZjcyMjE5"></p>
<p>HashMap 的性能表现非常依赖于哈希码的有效性，请务必掌握 hashCode 和 equals 的一些基本约定</p>
<p>比如：</p>
<ul>
<li>equals 相等，hashCode 一定要相等。</li>
<li>重写了 hashCode 也要重写 equals。</li>
<li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li>
<li>LinkedHashMap 通常提供的是遍历顺序符合插入顺序，它的实现是通过键值对维护一个双向链表。</li>
</ul>
<p>对于 TreeMap，它的整体顺序是由键的顺序关系决定的，通过 Comparator 或 Comparable（自然顺序）来决定。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://lswisdom.github.io/posts/221454775/" title="JDK1.8 HashMap源码简单讲解" target="_blank" rel="external">https://lswisdom.github.io/posts/221454775/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/timg.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark"></span><small class="ml-1x">LsWisdom Blog</small></a></h3>
        <div>宝剑锋从磨砺出，梅花香自苦寒来</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/2388768520/" title="红黑树"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/221454774/" title="证书生成方式"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lswisdom" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
    <script defer>
    var disqus_config = function () {
        
            this.page.url = 'https://lswisdom.github.io/posts/221454775/';
        
        this.page.identifier = 'JDK/JDK1.8 HashMap源码讲解';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + '' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>








</body>
</html>