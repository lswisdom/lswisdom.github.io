<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>HashMap简单讲解 | Hexo</title>
  <meta name="description" content="JDK1.7 HashMapJDK1.8 HashMap基本信息描述JDK1.7采用 数组+链表 的数据结构JDK1.8的HashMap采用 数组+链表+红黑树 的数据结构。新增加红黑树的操作,是为了解决某些情况下,链表过长导致的查询效率问题。链表查询数据的时间复杂度为O(n),红黑树的时间复杂度为Olog(n).当数据量多的时候,红黑树的查询效率明显高于链表数据结构如下： 基本字段属性12345">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap简单讲解">
<meta property="og:url" content="https://lswisdom.github.io/posts/221454777/index.html">
<meta property="og:site_name" content="LsWisdom的博客">
<meta property="og:description" content="JDK1.7 HashMapJDK1.8 HashMap基本信息描述JDK1.7采用 数组+链表 的数据结构JDK1.8的HashMap采用 数组+链表+红黑树 的数据结构。新增加红黑树的操作,是为了解决某些情况下,链表过长导致的查询效率问题。链表查询数据的时间复杂度为O(n),红黑树的时间复杂度为Olog(n).当数据量多的时候,红黑树的查询效率明显高于链表数据结构如下： 基本字段属性12345">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIC2.fqw2hciIGI4M2M2ZTIzOTYzYTQ3ZjI4YzY5YjBhNzBjOGNhNDU5">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/Jdk1.8%E6%9C%AA%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B9%8B%E5%89%8D%E7%9A%84%E5%BD%A2%E6%80%81.png?versionId=CAEQGxiBgMDP.fqw2hciIDQzYmNkYTQzZTNhMDQ4MmZhZDQyNjI1ZjZjYjJiOGRm">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/TreeifBean%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIDozMO02xciIDY0ZTNhMzM3NDgyZTRmNDdiY2JjMmNiYzc3ODAxOWI3">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png?versionId=CAEQGxiBgMDjvPS22xciIGZkMTE0MTNiYzg2ZjQ4OTRhNmIxZDM5ZWZiNTEzZGM0">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png?versionId=CAEQGxiBgICkk5W32xciIDgwNjlhNzU3MzczMTRlOGZhNTMwMjUwYjkwNGRjMjk5">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%83%85%E6%99%AF1.png?versionId=CAEQGxiBgIDA6J632xciIDQ4ODk5ODc2NzBlMTQ2NTQ5MDRiMTJiYmM3YWZiOGY5">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E6%99%AF3.png?versionId=CAEQGxiBgIDXhJax2hciIDU4NTU3MTA5ODQ3OTRhMGQ4MDNmNmUxNWUyZTg1NWI3">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E6%99%AF4.1%E5%8F%98%E6%8D%A2%E5%89%8D%E5%90%8E.png?versionId=CAEQGxiBgMDXhJax2hciIGJlMzQyNmM3YWQ4NzQ1Mzc4M2EyMTAzYzU2MzAwNDgz">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/LL%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86.png?versionId=CAEQGxiCgICihpax2hciIDViZDcwNjZiZTYyODQ0ZmM5MmZlNTRiZDNjYThhMzVk">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/LR%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%80%E6%AD%A5.png?versionId=CAEQGxiBgMCl1I242xciIGZhMWY2ZWIyZTNiYjRhMDU4ZTlkOTQ0MDc0OTllYzI2">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/LR%E5%A4%84%E7%90%861.png?versionId=CAEQGxiBgMCixc252xciIDJkYmFjM2MzNzlkODQ4NTlhZmIzZDdmNmI1MzlmZDg2">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1RR%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86.png?versionId=CAEQGxiBgMCmhpax2hciIGJiNGJjNTZkMmRjNDRlZWE4ODY2ZWI0Njc1OTYxMjE5">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B54.3.2%E7%AC%AC%E4%B8%80%E6%AD%A5.png?versionId=CAEQGxiCgIDngpax2hciIDViYTc2MTAxZTdmYTRmZDFiNjNiY2E3NjdlMzIwMTMx">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/RL%E6%83%85%E5%86%B5%E7%AC%AC2%E6%AD%A5.png?versionId=CAEQGxiBgID5u..52xciIGM0YTE1NjA5NTE0YjQ2ZGFhZTU5NjM1M2Y1MjcwZjlk">
<meta property="og:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png?versionId=CAEQGxiBgIDF.fqw2hciIGMxZjNiNzhmMDM0NzQyZjQ5OGE0MWY2OGM5MTg5MzZi">
<meta property="article:published_time" content="2021-08-17T16:09:14.000Z">
<meta property="article:modified_time" content="2022-10-30T03:04:44.277Z">
<meta property="article:author" content="ls">
<meta property="article:tag" content="Java集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIC2.fqw2hciIGI4M2M2ZTIzOTYzYTQ3ZjI4YzY5YjBhNzBjOGNhNDU5">
  <!-- Canonical links -->
  <link rel="canonical" href="https://lswisdom.github.io/posts/221454777/index.html">
  
    <link rel="alternate" href="/atom.xml" title="LsWisdom的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/timg.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm"></h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">LsWisdom Blog</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Hangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lswisdom" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>知识的碰撞能擦出不一样的火花!<br/> 欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">搜索引擎</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Es%E5%AD%A6%E4%B9%A0/" style="font-size: 13.5px;">Es学习</a> <a href="/tags/Java%E9%9B%86%E5%90%88/" style="font-size: 14px;">Java集合</a> <a href="/tags/Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" style="font-size: 13.5px;">Linux环境安装</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/docker/" style="font-size: 13px;">docker</a> <a href="/tags/kubernetes/" style="font-size: 13px;">kubernetes</a> <a href="/tags/vue/" style="font-size: 13px;">vue</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" style="font-size: 13px;">环境安装</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 13px;">线程</a> <a href="/tags/%E8%AF%81%E4%B9%A6/" style="font-size: 13.5px;">证书</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled ">
        
          <li>
            
            <div class="item-thumb">
              <a href="/posts/879582920/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/879582920/" class="title">部署k8s集群</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-29T10:06:57.000Z" itemprop="datePublished">2022-10-29</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/708881443/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
              </p>
              <p class="item-title">
                <a href="/posts/708881443/" class="title">Docker安装</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-29T07:01:26.000Z" itemprop="datePublished">2022-10-29</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/1082886779/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/posts/1082886779/" class="title">VUE基本使用和的组件介绍</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-20T13:37:58.000Z" itemprop="datePublished">2021-08-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/221454123/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">搜索引擎</a>
              </p>
              <p class="item-title">
                <a href="/posts/221454123/" class="title">Es简介</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-18T16:09:14.000Z" itemprop="datePublished">2021-08-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-thumb">
              <a href="/posts/221453123/" class="thumb">
    
    
        <span class="thumb-image thumb-none"></span>
    
</a>

            </div>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/posts/221453123/" class="title">ElasticSearch索引学习</a>
              </p>
              <p class="item-date">
                <time datetime="2021-08-18T16:09:14.000Z" itemprop="datePublished">2021-08-19</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jdk17-hashmap"><span class="toc-number">1.</span> <span class="toc-text">JDK1.7 HashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jdk18-hashmap"><span class="toc-number">2.</span> <span class="toc-text">JDK1.8 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">基本信息描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">基本字段属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E4%B8%AD%E5%85%83%E7%B4%A0%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.3.</span> <span class="toc-text">桶中元素结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%A0%91%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.4.</span> <span class="toc-text">链表树化结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%A1%B6%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.6.1.</span> <span class="toc-text">确定桶的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">hash方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9resize"><span class="toc-number">2.6.3.</span> <span class="toc-text">扩容resize()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.4.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.5.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%A0%91%E5%8C%96"><span class="toc-number">2.6.6.</span> <span class="toc-text">链表树化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#node%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9treeifybin"><span class="toc-number">2.6.6.1.</span> <span class="toc-text">Node转红黑树节点TreeifyBin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treenode%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91treeify"><span class="toc-number">2.6.6.2.</span> <span class="toc-text">TreeNode转红黑树treeify()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%87%AA%E5%B9%B3%E8%A1%A1"><span class="toc-number">2.6.6.3.</span> <span class="toc-text">红黑树的自平衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B"><span class="toc-number">2.6.6.4.</span> <span class="toc-text">红黑树的左旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8F%B3%E6%97%8B"><span class="toc-number">2.6.6.5.</span> <span class="toc-text">红黑树的右旋</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.7.</span> <span class="toc-text">红黑树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">2.8.</span> <span class="toc-text">红黑树的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF1%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%BA%E7%A9%BA%E6%A0%91"><span class="toc-number">2.8.1.</span> <span class="toc-text">情景1：插入的节点为空树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF2%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E7%9A%84key%E5%B7%B2%E5%AD%98%E5%9C%A8"><span class="toc-number">2.8.2.</span> <span class="toc-text">情景2：插入节点的Key已存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF3-%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E7%9A%84%E7%88%B6%E7%BB%93%E7%82%B9%E4%B8%BA%E9%BB%91%E7%BB%93%E7%82%B9"><span class="toc-number">2.8.3.</span> <span class="toc-text">情景3   插入结点的父结点为黑结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF4%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9%E4%B8%BA%E7%BA%A2%E8%89%B2"><span class="toc-number">2.8.4.</span> <span class="toc-text">情景4：插入节点的父节点为红色</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E6%99%AF41"><span class="toc-number">2.8.4.1.</span> <span class="toc-text">情景4.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF42"><span class="toc-number">2.8.4.2.</span> <span class="toc-text">插入情景4.2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ll%E7%BA%A2%E8%89%B2%E6%83%85%E5%86%B5"><span class="toc-number">2.8.4.2.1.</span> <span class="toc-text">LL红色情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lr%E7%BA%A2%E8%89%B2%E6%83%85%E5%86%B5"><span class="toc-number">2.8.4.2.2.</span> <span class="toc-text">LR红色情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B543"><span class="toc-number">2.8.4.3.</span> <span class="toc-text">情况4.3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rr%E7%BA%A2%E8%89%B2%E6%83%85%E5%86%B5"><span class="toc-number">2.8.4.3.1.</span> <span class="toc-text">RR红色情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rl%E7%BA%A2%E8%89%B2%E6%83%85%E5%86%B5"><span class="toc-number">2.8.4.3.2.</span> <span class="toc-text">RL红色情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E9%93%BE%E5%8C%96"><span class="toc-number">2.8.5.</span> <span class="toc-text">红黑树链化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8B%86%E5%88%86"><span class="toc-number">2.8.6.</span> <span class="toc-text">红黑树的拆分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91"><span class="toc-number">2.9.</span> <span class="toc-text">问题答疑：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%981"><span class="toc-number">2.9.1.</span> <span class="toc-text">问题1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%982"><span class="toc-number">2.9.2.</span> <span class="toc-text">问题2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%983"><span class="toc-number">2.9.3.</span> <span class="toc-text">问题3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%984"><span class="toc-number">2.9.3.1.</span> <span class="toc-text">问题4：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%985"><span class="toc-number">2.9.3.2.</span> <span class="toc-text">问题5</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.10.</span> <span class="toc-text">小结</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-JDK/HashMap简单讲解" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      HashMap简单讲解
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/posts/221454777/" class="article-date">
	  <time datetime="2021-08-17T16:09:14.000Z" itemprop="datePublished">2021-08-18</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/JDK/">JDK</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Java%E9%9B%86%E5%90%88/" rel="tag">Java集合</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/posts/221454777/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 13k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 53(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="jdk17-hashmap"><a href="#JDK1-7-HashMap" class="headerlink" title="JDK1.7 HashMap"></a>JDK1.7 HashMap</h1><h1 id="jdk18-hashmap"><a href="#JDK1-8-HashMap" class="headerlink" title="JDK1.8 HashMap"></a>JDK1.8 HashMap</h1><h2 id="基本信息描述"><a href="#基本信息描述" class="headerlink" title="基本信息描述"></a>基本信息描述</h2><p>JDK1.7采用 <code>数组+链表</code> 的数据结构<br>JDK1.8的HashMap采用 <code>数组+链表+红黑树</code> 的数据结构。新增加红黑树的操作,是为了解决某些情况下,链表过长导致的查询效率问题。链表查询数据的时间复杂度为O(n),红黑树的时间复杂度为Olog(n).当数据量多的时候,红黑树的查询效率明显高于链表<br>数据结构如下：<br><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIC2.fqw2hciIGI4M2M2ZTIzOTYzYTQ3ZjI4YzY5YjBhNzBjOGNhNDU5" alt="JDK1.8HashMap数据结构"></p>
<h2 id="基本字段属性"><a href="#基本字段属性" class="headerlink" title="基本字段属性"></a>基本字段属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合默认的容量是16,大小必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合的最大容量。初始化或者扩容时,防止溢出,必须是2次幂 &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数中未指定负载因子时,使用该值,默认是0.75,不建议修改,该值经过大量计算得出.遵循泊松分布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶的树化阈值  当链表长度&gt;=8 时,将链表转换成红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树还原回链表的阈值。当红黑树节点数量&lt;=6时,将红黑树转换为链表结构</span></span><br><span class="line"><span class="comment">     * 基于时间和空间的考虑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶树化的最小表容量： 当桶中的元素大于64时,且链表的容量&gt;=TREEIFY_THRESHOLD 时,才可以把链表转换为红黑树</span></span><br><span class="line"><span class="comment">     * 设置成64,是为了减少扩容的次数。当桶比较小的时候,桶中的元素达到一定的个数时,会频繁的扩容操作。浪费性能</span></span><br><span class="line"><span class="comment">     * 也是时间和空间的一种考虑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次使用时进行初始化操作。长度是2的幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  缓存字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hashmap改变的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 库容的阈值,大小等于 =  (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载因子,默认是0.75</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>   <code>TREEIFY_THRESHOLD=8</code> 和 <code>UNTREEIFY_THRESHOLD=6</code> 是链表转红黑树和红黑树退化成链表的阈值。因为桶中链表的数量在计算hash值的时候,遵循泊松分布。当链表的长度为8时的概率为 8:    0.00000006 而当链表的长度为6时的概率为 6:    0.00001316  概率差了1000多倍。为了避免频繁的树化和解除树化的操作</p>
<h2 id="桶中元素结构体"><a href="#桶中元素结构体" class="headerlink" title="桶中元素结构体"></a>桶中元素结构体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// hash值</span></span><br><span class="line">     <span class="keyword">final</span> K key; <span class="comment">// key值</span></span><br><span class="line">     V value; <span class="comment">// 桶中元素的value值</span></span><br><span class="line">     Node&lt;K,V&gt; next;  <span class="comment">// 桶中下一个元素的指针</span></span><br><span class="line"></span><br><span class="line">     Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.hash = hash;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表树化结构体"><a href="#链表树化结构体" class="headerlink" title="链表树化结构体"></a>链表树化结构体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  loadFactor      负载因子</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">  *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     <span class="comment">// 如果初始容量大于最大容量2^30,赋值为最大容量。防止溢出                                       </span></span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// threshold hashmap扩容阈值,注意这个值会发生变化,如果initialCapacity是2的幂,返回原值。如果不是2的幂,返回大于该值的最小的2的幂次方</span></span><br><span class="line">     <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定集合容量大小,默认负载因子是0.75</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用默认属性</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>注意：</code> 集合容量设置过小,会造成频繁的扩容操作。设置容量过大,会导致空间上浪费。如果我们确切的知道我们有多少键值对需要存储,那么我们在初始化HashMap的时候就应该指定它的容量,防止HashMap自动扩容,影响使用效率。 <code>initialCapacity = (需要存储的元素个数 / 负载因子) + 1</code></p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="确定桶的位置"><a href="#确定桶的位置" class="headerlink" title="确定桶的位置"></a>确定桶的位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算 key.hashCode() 并将散列的较高位（异或）传播到较低位。这个怎么理解呢?<br>这个哈希方法首先计算出key的hashCode,然后赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值(hashCode()计算方法,得出的是一个int类型数,转换为二进制也就是32位)。hash值计算完成后,需要用来计算元素在桶中的位置,计算公式:<code>tab[i = (n - 1) &amp; hash</code> 如果当桶很小时,假设是默认的16的话,这样的值和hashCode()直接做按位与操作,实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大,低位变化很小,这样就很容易造成哈希冲突了,所以这里把高低位都利用起来,从而解决了这个问题。<code>也是一种为了降低hash冲突的优化手段</code>。举个例子如下：</p>
<ul>
<li>&amp; (按位与运算) : 运算规则:相同的二进制数位上,都是1的时候,结果为1,否则为零。</li>
<li>^ (按位异或运算) :运算规则:相同的二进制数位上,数字相同,结果为0,不同为1.</li>
</ul>
<p>代码中通过这个hash &amp; (n-1) 得到存储元素的位置,假设这里的h = key.hashCode()得到的值为,分别进行桶中元素位置计算,看看新老hash算法差异<br>key1 = 0000 0000 0001 0000 1111 1111 0000 0000<br>key2 = 0000 1111 1111 1111 1111 1111 0000 0000   高位变化较大   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">使用h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span> 获取hash值</span><br><span class="line">key1的计算如下：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>    h</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span>    h &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0000</span>   按位异或运算后得到的hash值  h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">此时数据长度n假设为默认的<span class="number">16</span>,那么这个key存放在table中位置为i = (n - <span class="number">1</span>) &amp; hash</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0000</span>      hash</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>      n-<span class="number">1</span> <span class="number">15</span>   &amp;运算</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>     索引位置为<span class="number">0</span></span><br><span class="line">key2的计算：</span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>    h</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    h &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span>    按位异或运算后得到的hash值  h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span>    </span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>      n-<span class="number">1</span> <span class="number">15</span>   &amp;运算</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>    索引位置是<span class="number">15</span></span><br><span class="line">  </span><br><span class="line">反例： (key.hashCode()) &amp; (n-<span class="number">1</span>)</span><br><span class="line">key1:</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>      hash值(重新获取一个hash值,直接进行按位与操作)</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>      n-<span class="number">1</span> <span class="number">15</span>   &amp;运算</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>      索引位置为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">key2:</span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0000</span>      hash值  高位变化较大的hash值,低位保持不变</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span>      n-<span class="number">1</span> <span class="number">15</span>   &amp;运算 </span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>      索引位置为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>由此可见,同样的两个hashcode,经过<code>移位和异或</code>操作后,能够使hashcode更加复杂,同时也把哈希值的高位移动到了低位,降低了hash冲突的概率。实际上hashMap的hash算法做的非常好,进过我的测试,默认负载因子为0.75的时候如果把hashmap加入4000w个数据的时候。依然没有链表转红黑树的操作,都是不断扩容的操作.有兴趣的朋友,可以自己测试一下hash算法的性能。</p>
<h3 id="扩容resize"><a href="#扩容resize" class="headerlink" title="扩容resize()"></a>扩容resize()</h3><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     * 初始化或者扩容表的长度为2倍</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 旧表,第一次执行时,oldTabl为空</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 旧表的容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 旧的扩容阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// oldCap大于0说明是对数组进行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果扩容前旧表的容量大于阈值,就设置为Integer的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;  <span class="comment">// 如果旧表的长度左移一位还小于表的最大容量,就扩容表的长度为旧表的一倍,域值也为原来的一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">// HashMap的构造方法中会对threshold进行初始化操作</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;   </span><br><span class="line">            <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 初始化新容器的大小,必须是2的幂,默认是16。表刚创建的时候,会执行到这里</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">// 默认的阈值是12 负载因子0.75* 默认的初始化容量16</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的阈值为0时,按照阈值公式计算阈值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新table表扩容时的的阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">// 用扩容后的容量创建新的数组然后返回数据</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 如果是初始化数组,下面的部分不会执行,下面的部分涉及到数组中元素的移动</span></span><br><span class="line">        <span class="comment">// 扩容,进行数据迁移</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 移动旧表的数据到新表中,移动的扩容中,需要重新的进行hash操作</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 如果数组中只有一个元素,直接移动即可</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">// 如果是红黑树,需要对红黑树进行拆分</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order  维持相对顺序</span></span><br><span class="line">                        <span class="comment">// 链表节点的处理  head是头节点  tail是尾部节点</span></span><br><span class="line">                        <span class="comment">// loHead是低位链表  hiHead是高位链表</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                         <span class="comment">// 获取当前节点的下一个节点,每一次循环e值会更新</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 遍历链表,将链表按照计算后的位置进行分组</span></span><br><span class="line">                            <span class="comment">// 没有再次hash的操作,而是按照扩容后新增加的那个bit是0还是1进行分组</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                            </span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 分组完成后,将链表映射到桶中</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 扩容后的链表的存储位置</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回扩容后新表的长度</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码流程介绍：<br>    1. 判断是初始化或者扩容操作,计算相应的新数组容量newCap 和 新的阈值大小newThr<br>    2. 初始化新的数组容量newCap<br>    3. 如果是扩容操作,还需要进行一个元素移动的操作。在移动的过程中,分为三种操作：<br>        3.1 如果原数组中只有一个元素,并且next指针为空,直接移动即可 newTab[e.hash &amp; (newCap - 1)] = e;<br>        3.2 如果原数组中的元素是树节点。需要将元素进行拆分,然后映射存储位置<br>        3.3 对于链表元素,需要将元素进行拆分。拆分为2个链表。可以理解为低位链表和高位链表,低位链表存储在扩容后的数组原来的位置,高位链表存储在扩容后数组原来的位置+旧数组容量的位置</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key获取其所对应的value值</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="comment">// 计算key值的hashcode。目的是为了通过(n - 1) &amp; hash 计算出当前key值在hash表中的位置</span></span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap根据key值和和key的HashCode值查找元素</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash 当前key的hash值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 当前key元素</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">     <span class="comment">// 如果数组中有元素同时根据hash值计算出当前key值所在的位置不为空</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 检查数组中的元素。判断头结点是否就是需要获取的元素    </span></span><br><span class="line">         <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">             ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">// 如果头节点中没有,从头结点的下一个节点开始查找    </span></span><br><span class="line">         <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果头节点是红黑树。则从红黑树中查找</span></span><br><span class="line">             <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果下一个节点不是红黑树。就只能是链表节点。在链表节点中查找元素</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">return</span> e;</span><br><span class="line">             &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>get方法整体上比较简单,就是根据key的hash值,查找元素在数组的位置,找到之后判断是链表还是红黑树。如果是红黑树,就从红黑树的节点中去寻找。如果是链表节点,就遍历链表去查找相应的key所对应的value的值</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>put方法相对复杂一些,其实也还好,如果熟悉红黑树这种数据结构的话,看起来也不是很复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过高16位和低16位的异或运算的到一个hash值</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正的添加元素方法。尾插法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value  是否进行元素的替换,用于插入相同key的时候,是否替换值,默认值为false,替换相应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// hashmap的table表的初始化操作,是在这里进行的。第一次执行的时候,会先在这里进行初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过hash值和数组长度进行按位与运算,得到元素的存储位置,如果table表的位置为空,就直接新建一个Node节点进行存储操作    </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// key映射的数组桶位置有元素,也就是产生了hash碰撞(hashmap采用链地址法解决hash冲突。),走下述代码</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在该位置的第一个数据的key值和插入的元素的key值相等。需要进行下面的if (!onlyIfAbsent || oldValue == null) 的替换操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶中的元素是红黑树节点。就在红黑树中新插入节点,插入完成后,然后调整红黑树 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在链表中插入节点。这里先对链表进行遍历操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//  遍历链表时,取下一个位置存放新增的元素,这里采用的是尾插法(链表中不包含要插入键值对节点)</span></span><br><span class="line">                <span class="comment">//  a.横竖都要遍历链表的长度是否大于树化的阈值,所以遍历的过程中,就直接插入元素了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果链表的长度大于8个时,就进行链表转红黑树的操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果在链表中找到了相同的key值。直接break操作。那么e节点此时就是与链表要插入的新值key相同的Node节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  key值存在,就替换value值。新插入的元素的value值,替换原来这个key的value值,注意onlyIfAbsent 这个值</span></span><br><span class="line">        <span class="comment">//  这个值表示是否仅在oldValue==null 的时候,更新键值对的值。key相同会进行值覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果hashmap中元素的值超过了阈值,就会进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>put方法小结：<br>1.当桶中的元素为空值,通过扩容的方式进行初始化table<br>2.对key进行hash运算。得到需要存储在桶中的位置。如果桶中位置为空,直接在桶中放入元素即可。<br>3.如果桶中的元素不为空。需要先查找插入的key值,是否已经存在,如果已经存在,则需要使用新值替换旧值,<br>4.如果不存在,则将新插入的key值插入在链表的尾部或者红黑树中。其中插入到链表尾部的过程中还会判断链表的长度是否大于树化的阈值。如果大于阈值,就会进行链表转红黑树的操作<br>5.最后判断数组中的数量是否大于扩容阈值,如果大于,会进行数组的扩容操作</p>
<p>转换后的形态,可能如下图所示,我主要为了展示大体的数据结构,不要纠结于元素的值<br><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/Jdk1.8%E6%9C%AA%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B9%8B%E5%89%8D%E7%9A%84%E5%BD%A2%E6%80%81.png?versionId=CAEQGxiBgMDP.fqw2hciIDQzYmNkYTQzZTNhMDQ4MmZhZDQyNjI1ZjZjYjJiOGRm"></p>
<h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><p>JDK1.8 对hashmap进行了改进。采用的数组+链表+红黑树的存储结构。链表转红黑树的操作,主要是为了防止由于hashcode算法性能不佳等原因,造成链表长度过长,查询缓慢的问题,我们元素多的情况下,红黑树是指数级的时间复杂度,在性能上远高于链表的时间复杂度。虽然会有一些额外的空间的消耗,但是时间上能大幅度提升。下面我将介绍 <code>链表树化</code> 、<code>红黑树自平衡</code>、<code>红黑树的基本性质</code></p>
<h4 id="node转红黑树节点treeifybin"><a href="#Node转红黑树节点TreeifyBin" class="headerlink" title="Node转红黑树节点TreeifyBin()"></a>Node转红黑树节点TreeifyBin()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> 	替换指定哈希表的索引桶中所有的连接节点,除非表太小,否则将修改大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     *    如果元素数组为空 或者 数组长度小于 树结构化的最小阈值（MIN_TREEIFY_CAPACITY=64） ,就进行扩容操作.对于这个值可以理解为：如果元素数组长度小于这个值,没有必要去进行结构转换.目的是</span></span><br><span class="line"><span class="comment">     *  如果数组很小,那么转红黑树,遍历效率要低一些,这时进行扩容操作,重新计算哈希值,链表的长度有可能就变短了。数据会放入到数组中,这样相对来说效率会高一些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">        <span class="comment">//如果元素数组长度已经大于等于了 MIN_TREEIFY_CAPACITY,那么就有必要进行结构转换了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出数组对应位置的头节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//定义几个变量,hd(head)代表头节点,tl代表尾节点(tail) 算法中常用变量</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">//先把普通Node节点转成TreeNode类型,并赋值给p</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//用新生成的双向链表替代旧的单向链表,其实就是把这个数组对应的位置重新赋值成新双向链表的首节点  hd是index对应的桶的首节点</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>treeifyBin()方法总结</p>
<ul>
<li>链表转红黑树的条件：<ul>
<li>链表长度大于等于树化阈值 <code>TREEIFY_THRESHOLD = 8</code></li>
<li>数组长度大于等于<code>MIN_TREEIFY_CAPACITY=64 </code></li>
</ul>
</li>
<li>方法执行步骤：<ul>
<li>如果元素数组长度已经大于等于了 MIN_TREEIFY_CAPACITY,就进行结构转换,具体为Node转换为TreeNode节点。否则进行扩容操作</li>
<li>TreeNode节点间接继承自Node节点,所以TreeNode节点包含next引用。原链表顺序最终通过next引用被保存下来</li>
<li>最后一行,调用<code>treeify</code> 将链表转换为红黑树<br>转换后的元素结构,可能是这么一种形态<br><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/TreeifBean%E5%90%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png?versionId=CAEQGxiBgIDozMO02xciIDY0ZTNhMzM3NDgyZTRmNDdiY2JjMmNiYzc3ODAxOWI3"></li>
</ul>
</li>
</ul>
<h4 id="treenode转红黑树treeify"><a href="#TreeNode转红黑树treeify" class="headerlink" title="TreeNode转红黑树treeify()"></a>TreeNode转红黑树treeify()</h4><p>下面就是链表转红黑树的核心逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将树形链表转换为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//  遍历链表,x指向当前节点、next指向下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">// 记录x的下一个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果根节点为空,则把当前节点当做根节点。根据红黑树性质,根节点一定为黑色。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根节点已经存在的情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 取得当前遍历的树形节点的 key 和 hash</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// TODO : 循环开始位置</span></span><br><span class="line">            <span class="comment">// 从根节点遍历。这一步主要就是为了判断当前节点应该在树的左侧还是右侧,为节点x找到空位置并插入元素</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="comment">// dir代表方向(左边或者右边)  ph表示树节点的hash值。</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;  </span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 比较hash值大小,判断当前节点插入到左边还是右边,并记录dir的值</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) </span><br><span class="line">                    dir = -<span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据比较器判断大小     Comparable 接⼝判断</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 通过key的类名比较    </span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存当前遍历的树节点,就是x节点要插入的位置的父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// 判断如果dir&lt;=0 说明当前节点的hash值小于当前树节点的hash值。需要把当前节点放置在当前树节点的左侧</span></span><br><span class="line">                <span class="comment">// 判断如果dir&gt;0 说明当前节点的hash值大于当前树节点的hash值。 需要把当前节点放置在当前树节点的右侧</span></span><br><span class="line">                <span class="comment">// p的左右节点存在不为空的情况,p节点就是当前遍历的树节点,说明该节点还有子节点。继续循环查找当前节点x的应该在哪个爸爸节点下面插入元素</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// x 节点找到了父节点,并将x节点放入到父节点下面</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 元素插入之后,需要进行红黑树的自平衡操作,重新确定根节点的值</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保根节点作为第一个节点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>treeify() 方法执行小结：</p>
<ul>
<li>遍历第⼀个节点时,此时红⿊树不存在,以第⼀个节点作为红⿊树根节点,并转换为黑节点</li>
<li>有了红⿊树后,此后遍历双链表的每个节点时,都要根据红黑树性质从根节点开始寻找要插⼊当前节点的位置,也就是找到⼀个⽗节点,将当前节点作为其左节点或右节点。</li>
<li>插⼊节点后,可能会导致红⿊树特性被破坏,因此每次插⼊节点后要尝试重新调整红⿊树</li>
<li>红黑树调整完成后,要确保根节点就是table桶中的第一个节点</li>
</ul>
<h4 id="红黑树的自平衡"><a href="#红黑树的自平衡" class="headerlink" title="红黑树的自平衡"></a>红黑树的自平衡</h4><p>下面我将介绍红黑树的<code>自平衡操作</code> 这部分代码纯粹就是红黑树的操作了,根hashmap没有多个的关系,有一定数据结构基础的同学,看起来应该没什么难度,对于不了解红黑树的同学,我将在下面代码的下面讲解红黑树的基本操作,帮助你理解如下代码。或者你可以看看我的另一篇文章《红黑树的简单介绍》 </p>
<pre><code> * 红黑树插入节点后,需要进行平衡操作
 *       情景1： 红黑树为空树时,将根节点染成黑色
 *       情景2： 插入的节点在红黑树已经存在,不需要处理
 *       情景3： 插入节点的父节点为黑色,因为所插入的路径,黑色节点没有发生变化,所以红黑树依然平衡,所以不需要处理
 *       情景4： 插入节点的父节点为红色
 *              情景4.1  叔叔节点存在,并且为红色(父和叔  都是红色节点) 根据红黑树性质4.红色节点不能直接相连,由此可知必然存在爷爷节点,且爷爷节点必定为黑节点
 *                          由此可以 a.将爸爸和叔叔节点变成黑色  b.将爷爷节点变成红色  c.并且将爷爷节点当成当前节点,进行下一轮的处理
 *              情景4.2  叔叔节点不存在或者为黑色节点,父节点为爷爷节点的左子树
 *                      情景4.2.1 插入节点为其父节点的左子节点(LL情况) a.将爸爸节点染成黑色 b.将爷爷染成红色 c.然后以爷爷节点进行右旋操作
 *                      情景4.2.2 插入节点为其父节点的右子节点(LR情况) a.已爸爸为节点进行一次左旋操作,得到(LL双红的情况 4.2.1) 然后指定爸爸节点为当前节点,执行下一轮的操作
 *              情景4.3  叔叔节点不存在,或者为黑色节点,父节点为爷爷节点的右子树
 *                      情景4.3.1 插入节点为其父节点的右子节点(RR情况) a.将爸爸染成黑色节点  b.将爷爷染成红色 c.然后以爷爷节点进行左旋操作
 *                      情景4.3.2 插入节点为其父节点的左子节点(RL情况) a.以爸爸节点进行一次右旋,得到RR双红的场景( RR情况 4.3.1).然后指定爸爸节点为当前节点,进行下一轮的操作
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认插入节点为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xp为父节点  xpp：为爷爷节点   xxpl是爷爷的左节点(左叔叔节点)  xppr：是爷爷节点的右节点(右叔叔节点)</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情景1:当前节点的父节点不存在,当前节点就是根节点,根据红黑色性质,根节点为黑色,直接变色就可以了</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情景2 和情景3：插入节点的父节点为黑色,因为所插入的路径,黑色节点没有发生变化,所以红黑树依然平衡,所以不需要处理。 爷节为空,说明x节点的父节点为根节点,可以直接插入节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情景4：如果父节点为红色,同时是父节点是爷爷节点的左节点,这样就遇到了两个红色节点相连的情况,需要进行处理。根据上述公式分为两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//  如果爷爷节点的右节点不为空,同时是红节点(也就是右叔叔节点不为空,且为红色.父叔双红)</span></span><br><span class="line">            <span class="comment">//  情景4.1  叔叔节点存在,并且为红色(父和叔  都是红色节点)  a.将爸爸和叔叔节点变成黑色  b.将爷爷节点变成红色  c.并且将爷爷节点当成当前节点,进行下一轮的处理</span></span><br><span class="line">            <span class="comment">//  因为有小伙伴有疑问：这个下一轮处理就是指(xpp节点变成红色后,可能会和xpp节点的父节点发生冲突,也就是两个连续的红色节点,所以需要继续处理) </span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  情景4.2  叔叔节点不存在或者为黑色节点,父节点为爷爷节点的左子树。分为两种情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 这些变化操作,你画画图就明白了,单纯的看比较抽象</span></span><br><span class="line">                 <span class="comment">// 情景4.2.2 插入节点为其父节点的右子节点(LR双红情况) a.以爸爸为节点进行一次左旋操作,得到(LL双红的情况 4.2.1) 然后指定爸爸节点为当前节点,执行下一轮的操作</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景4.2.1 插入节点为其父节点的左子节点(LL情况) a.将爸爸节点染成黑色 b.将爷爷染成红色 c.然后以爷爷节点进行右旋操作</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情景4.1  叔叔节点存在,并且为红色(父和叔  都是红色节点) 此时爸爸节点为爷爷节点的右节点和上述情况相反</span></span><br><span class="line">            <span class="comment">// a.将爸爸和叔叔节点变成黑色  b.将爷爷节点变成红色  c.并且将爷爷节点当成当前节点,进行下一轮的处理(xpp节点变成红色后,可能会和xpp节点的父节点发生冲突,也就是两个连续的红色节点,所以需要继续处理)</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果爷爷节点的左节点是黑色或者为空(左叔叔节点) 。那么可能有两种情况：</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情景4.3.2 插入节点为其父节点的左子节点(RL情况)  a.以爸爸节点进行一次右旋,得到RR双红的场景( RR情况 4.3.1).然后指定爸爸节点为当前节点,进行下一轮的操作</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    <span class="comment">// 平衡过后,重新定义爷爷节点的变量值</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 情景4.3.1 插入节点为其父节点的右子节点(RR情况) a.将爸爸染成黑色节点  b.将爷爷染成红色 c.然后以爷爷节点进行左旋操作</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纯粹就是红黑树的操作了,这没什么可说的。红黑树需要考虑的场景,我已经在方法上面标注过了,并在代码中给了提示,相信各位同学能很清楚的看明白</p>
<h4 id="红黑树的左旋"><a href="#红黑树的左旋" class="headerlink" title="红黑树的左旋"></a>红黑树的左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"><span class="comment">// 红黑树的左旋的过程</span></span><br><span class="line"><span class="comment">// 1 将节点 p 旋转为其右节点的左节点,即将节点 p 挂到其右节点的左边</span></span><br><span class="line"><span class="comment">// 2 其右节点的左节点成为节点p 的右节点</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// r -&gt;  节点 p 的右节点</span></span><br><span class="line">    <span class="comment">// rl -&gt; 节点 p 的右节点的左节点</span></span><br><span class="line">    <span class="comment">// pp -&gt; 节点 p 的⽗节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p 不为空且右节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 1 将 p 的右节点的左节点挂到 p 的右节点,这有两个信息</span></span><br><span class="line">        <span class="comment">// a. 断开 p 与其右节点 r 的连接</span></span><br><span class="line">        <span class="comment">// b. 因为 p 要挂到其右节点 r 的左边,因此要把节点 r 原来的左节点挂到 p 的右边</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// r 节点的左节点的⽗节点重置为 p</span></span><br><span class="line">            rl.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 将 p 的⽗节点设置为 p 的右节点的⽗节点</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">// 如果 p 为 root 节点,那么直接将其右节点设置为 root</span></span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 确定 r 节点应该挂在 p 的⽗节点的左边还是右边。这个根据 p 的位置决定。原来在左边,现在就还在左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 将 p 设置为其右节点的左边</span></span><br><span class="line">        </span><br><span class="line">        r.left = p;</span><br><span class="line">        <span class="comment">// 5 将 p 的右节点指为其⽗节点</span></span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单独看上面的左旋方法,可能很抽象,根据节点名称,我画了一个草图帮助你们理解,这个图我已经画的很详细了</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png?versionId=CAEQGxiBgMDjvPS22xciIGZkMTE0MTNiYzg2ZjQ4OTRhNmIxZDM5ZWZiNTEzZGM0"></p>
<h4 id="红黑树的右旋"><a href="#红黑树的右旋" class="headerlink" title="红黑树的右旋"></a>红黑树的右旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 红黑树右旋：</span></span><br><span class="line"><span class="comment">* 1 将节点 p 旋转为其左节点的右节点,即将节点 p 挂到其左节点的右边</span></span><br><span class="line"><span class="comment">* 2 其左节点的右节点成为节点 p 的左节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  l -&gt; 节点 P 的左节点</span></span><br><span class="line">    <span class="comment">// pp -&gt; 节点 p 的⽗节点</span></span><br><span class="line">    <span class="comment">// lr -&gt; 节点 p 的左节点的右孩⼦</span></span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 节点 p 和 其左节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 将 p 的左节点的右孩⼦挂到 p 的左边</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 p 指定为 lr 的⽗节点</span></span><br><span class="line">            lr.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2 将 p 的⽗节点指定为其右节点的⽗节点     </span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将l节点设置为root节点,并调整为黑色.</span></span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 确定 p 的右节点应该挂在 p的⽗节点左边还是右边.这个根据 p 的位置决定。原来在左边,现在就还在左边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 p 设置为其左节点的右孩⼦    </span></span><br><span class="line">        l.right = p;</span><br><span class="line">        <span class="comment">// 将 p 的⽗节点指定为其左节点</span></span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了帮助理解,同样的,下面增加了红黑树的右旋代码示意图</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png?versionId=CAEQGxiBgICkk5W32xciIDgwNjlhNzU3MzczMTRlOGZhNTMwMjUwYjkwNGRjMjk5"></p>
<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><ul>
<li>红黑树性质<ul>
<li>性质1: 每个节点要么是黑色,要么是红色。</li>
<li>性质2: 根节点是黑色。</li>
<li>性质3: 每个叶子节点(NIL) 是黑色。</li>
<li>性质4: 每个红色节点的两个子节点一定都是黑色。</li>
<li>性质5: 任意节点到每个叶子节 点的路径都包含数量相同的黑结点。从性质5又可以推出:</li>
<li>性质5.1:如果一个节点存在黑子节点, 那么该结点肯定有两个子节点</li>
</ul>
</li>
</ul>
<h2 id="红黑树的场景"><a href="#红黑树的场景" class="headerlink" title="红黑树的场景"></a>红黑树的场景</h2><p>插入场景：</p>
<h3 id="情景1插入的节点为空树"><a href="#情景1：插入的节点为空树" class="headerlink" title="情景1：插入的节点为空树"></a>情景1：插入的节点为空树</h3><p>直接把插入的节点作为根节点就可以了,并且把根节点变成黑色,如下图所示：<br><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%83%85%E6%99%AF1.png?versionId=CAEQGxiBgIDA6J632xciIDQ4ODk5ODc2NzBlMTQ2NTQ5MDRiMTJiYmM3YWZiOGY5"></p>
<h3 id="情景2插入节点的key已存在"><a href="#情景2：插入节点的Key已存在" class="headerlink" title="情景2：插入节点的Key已存在"></a>情景2：插入节点的Key已存在</h3><p>处理：更新当前节点的值,为插入节点的值</p>
<h3 id="情景3-插入结点的父结点为黑结点"><a href="#情景3-插入结点的父结点为黑结点" class="headerlink" title="情景3   插入结点的父结点为黑结点"></a>情景3   插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的,并不会影响红黑树的平衡,直接插入即可,无需做自平衡。如图所示：</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E6%99%AF3.png?versionId=CAEQGxiBgIDXhJax2hciIDU4NTU3MTA5ODQ3OTRhMGQ4MDNmNmUxNWUyZTg1NWI3"></p>
<h3 id="情景4插入节点的父节点为红色"><a href="#情景4：插入节点的父节点为红色" class="headerlink" title="情景4：插入节点的父节点为红色"></a>情景4：插入节点的父节点为红色</h3><p>红黑树的性质2:  根结点是黑色,如果插入节点的父结点为红结点,那么该父结点不可能为根结点,所以插入结点总是存在祖父结点。</p>
<p>分为两种情况,如下图所示</p>
<ul>
<li>一种是爸爸节点为红色,叔叔节点也是红色</li>
<li>一种是爸爸节点为红色,叔叔节点为黑色或者不存在</li>
</ul>
<h4 id="情景41"><a href="#情景4-1" class="headerlink" title="情景4.1"></a>情景4.1</h4><p><strong>叔叔结点存在并且为红结点</strong></p>
<p>依据红黑树<strong>性质4</strong> 可知,红色节点不能相连==&gt;祖父结点肯定为黑结点。因为<code>不可以同时存在两个相连的红结点</code>。那么此时该插入子树的红黑层数的情况是<code>黑红红</code>。显然最简单的处理方式是把其改为<code>红黑红</code><br>处理:</p>
<ul>
<li>1  将爸爸节点(P)和叔叔节点(U)节点改为黑色</li>
<li>2  将爷爷PP改为红色</li>
<li>3  将爷爷PP设置为当前节点,进行后续处理.注意但需要注意的是 PP 变为红⾊后,可能会和它的⽗节点形成连续的红⾊节点,此时需要递归向上调整,也就将 PP 看作新插⼊节点继续尝试调整。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E6%99%AF4.1%E5%8F%98%E6%8D%A2%E5%89%8D%E5%90%8E.png?versionId=CAEQGxiBgMDXhJax2hciIGJlMzQyNmM3YWQ4NzQ1Mzc4M2EyMTAzYzU2MzAwNDgz"></p>
<p>可以看到,我们把PP结点设为红色了,如果PP的父结点是黑色,那么无需再做任何处理;但如果PP的父结点是红色,则违反了红黑树的性质.所以需要将PP设置为当前节点,继续做插入操作自平衡处理,真到平衡为为止.</p>
<h4 id="插入情景42"><a href="#插入情景4-2" class="headerlink" title="插入情景4.2"></a>插入情景4.2</h4><p><strong>叔叔结点不存在或为黑结点,并且插入结点的父亲结点是祖父结点的左子结点</strong></p>
<p>注意:单纯从插入前来看,叔叔节点非红即空(NIL节点) ,否则的话破坏了红黑树性质5,此路径会比其它路径多一个黑色节点。</p>
<p>新插入节点,可能为P节点的左子节点,也可能是P节点的右子节点,所以分为两种情况分别处理</p>
<h5 id="ll红色情况"><a href="#LL红色情况" class="headerlink" title="LL红色情况"></a>LL红色情况</h5><p><strong>4.2.1 新插入节点,为其父节点的左子节点</strong><br>处理:</p>
<ol>
<li>将P设置 为黑色,将PP设置为红色 ,然后以爷爷节点为当前节点</li>
<li>对PP节点进行右旋</li>
</ol>
<p>处理结果如下图所示：</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/LL%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86.png?versionId=CAEQGxiCgICihpax2hciIDViZDcwNjZiZTYyODQ0ZmM5MmZlNTRiZDNjYThhMzVk"></p>
<h5 id="lr红色情况"><a href="#LR红色情况" class="headerlink" title="LR红色情况"></a>LR红色情况</h5><p><strong>4.2.2 新插入节点,为其父节点的右子节点(LR红色情况)</strong><br>处理:</p>
<ul>
<li>对P进行左旋  </li>
<li>将P设置为当前节点,得到LL红色情况 </li>
<li>按照LL红色情况处理(1.变颜色2.右旋PP)</li>
</ul>
<p>操作过程如下图所示：</p>
<p>第一步</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/LR%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86%E7%AC%AC%E4%B8%80%E6%AD%A5.png?versionId=CAEQGxiBgMCl1I242xciIGZhMWY2ZWIyZTNiYjRhMDU4ZTlkOTQ0MDc0OTllYzI2"></p>
<p>第二步<br><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/LR%E5%A4%84%E7%90%861.png?versionId=CAEQGxiBgMCixc252xciIDJkYmFjM2MzNzlkODQ4NTlhZmIzZDdmNmI1MzlmZDg2"></p>
<h4 id="情况43"><a href="#情况4-3" class="headerlink" title="情况4.3"></a>情况4.3</h4><p><strong>叔叔结点不存在或为黑结点,并且插入结点的父亲结点是祖父结点的右子结点</strong> 和上述操作4.2 相反图,如下所示：</p>
<h5 id="rr红色情况"><a href="#RR红色情况" class="headerlink" title="RR红色情况"></a>RR红色情况</h5><p><strong>4.3.1新插入节点,为其父节点的右子节点(RR红色情况)</strong></p>
<p>处理操作：</p>
<ol>
<li>将P设置为黑色,将PP设置为红色</li>
<li>对PP节点进行左旋 </li>
</ol>
<p>旋转过程如下图所示：</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/4.3.1RR%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86.png?versionId=CAEQGxiBgMCmhpax2hciIGJiNGJjNTZkMmRjNDRlZWE4ODY2ZWI0Njc1OTYxMjE5"></p>
<h5 id="rl红色情况"><a href="#RL红色情况" class="headerlink" title="RL红色情况"></a>RL红色情况</h5><p><strong>4.3.2 新插入节点,为其父节点的左子节点(RL红色情况)</strong></p>
<p>处理:<br>1.对P进行右旋<br>2.将P设置为当前节点,得到RR红色情况<br>3.按照RR红色情况处理(1.变颜色2.左旋PP)</p>
<p>第一步对P节点进行右旋操作   如下图所示：</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/%E6%83%85%E5%86%B54.3.2%E7%AC%AC%E4%B8%80%E6%AD%A5.png?versionId=CAEQGxiCgIDngpax2hciIDViYTc2MTAxZTdmYTRmZDFiNjNiY2E3NjdlMzIwMTMx"></p>
<p>第二步：变色+旋转,如下图所示</p>
<p><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/RL%E6%83%85%E5%86%B5%E7%AC%AC2%E6%AD%A5.png?versionId=CAEQGxiBgID5u..52xciIGM0YTE1NjA5NTE0YjQ2ZGFhZTU5NjM1M2Y1MjcwZjlk"></p>
<h3 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">     * this node.</span></span><br><span class="line"><span class="comment">     * 红⿊树中仍然保留了原链表节点顺序。有个这个特点,再将红⿊树转成链表就简单多了,仅需将TreeNode 链表转成 Node 类型的链表即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ⽤于组织链表的头、尾指针</span></span><br><span class="line">        Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 TreeNode 链表,并⽤ Node 替换</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tl.next = p;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码链画的过程,相当简单,没什么可说的</p>
<h3 id="红黑树的拆分"><a href="#红黑树的拆分" class="headerlink" title="红黑树的拆分"></a>红黑树的拆分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment"> * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment"> * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//  重新链接到 lo 和 hi 列表,保持顺序</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 红⿊树节点仍然保留了 next 引⽤,因此仍可以按链表⽅式遍历红⿊树。下⾯的循环是对红⿊树节点进⾏分组,与普通链表操作类似</span></span><br><span class="line"><span class="comment">      * 下面这个循环进行的事链表的分组曹组</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loHead 不为空,且链表⻓度⼩于等于 6,则将红⿊树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">// hiHead == null 时,表明扩容后,所有节点仍在原位置,树结构不变,⽆需重新树化,否则,将 TreeNode 链表重新树化</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>这段逻辑发生在数据扩容的时候,对于红黑树节点的处理。<br>红黑树的扩容逻辑和链表的扩容逻辑整体上类似。唯一不同的是,除了这段逻辑将红黑树分组后,会判断链表的长度,如果小于UNTREEIFY_THRESHOLD ,会进行红黑树转链表的操作。否则根据条件,将链表树化为红黑树</p>
<h2 id="问题答疑"><a href="#问题答疑：" class="headerlink" title="问题答疑："></a>问题答疑：</h2><h3 id="问题1"><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><p><strong>问题：为什么集合的初始容量必须是2的n次幂?如果输入值不是2的幂,比如17会怎么样?</strong></p>
<p>这样做是为了<code>减少</code>hash碰撞的次数, 2的n次方实际就是1后面n个0,2的n次方减1二进制表示时实际就是n个1</p>
<blockquote>
<p><strong>按位与运算</strong> : 相同的二进制数位上,都是1的时候,结果为1,否则为零。</p>
</blockquote>
<blockquote>
<p><strong>按位或运算</strong> ： 相同的二进制数位上,都是0的时候,结果为0,否则为1。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">hash计算存放位置的时候,是通过 hash &amp; (length-1)</span><br><span class="line">例如1：</span><br><span class="line">hash值如果为3,hashmap默认容量为16  ,即 3 &amp; (16-1)</span><br><span class="line">0000 0011    3</span><br><span class="line">0000 1111    15</span><br><span class="line">------------------</span><br><span class="line">0000 0011    3  索引值为3</span><br><span class="line"></span><br><span class="line">例如2：</span><br><span class="line">hash值如果为5,hashmap默认容量为16  ,即 5 &amp; (16-1)</span><br><span class="line">0000 0101    5</span><br><span class="line">0000 1111    15</span><br><span class="line">------------------</span><br><span class="line">0000 0101    5  索引值为5</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line">如果不是2的n次幂</span><br><span class="line">hash值如果为3,hashmap容量设置为17  ,即 3 &amp; (17-1)</span><br><span class="line">0000 0011    3  </span><br><span class="line">0001 0000    16</span><br><span class="line">------------------</span><br><span class="line">0000 0000    0 索引位置为0</span><br><span class="line"></span><br><span class="line">hash值如果为7,hashmap容量设置为17  ,即 7 &amp; (17-1)</span><br><span class="line">0000 0111    7</span><br><span class="line">0001 0000    16</span><br><span class="line">------------------</span><br><span class="line">0000 0000    0 索引位置为0</span><br><span class="line"></span><br><span class="line">hash值如果为9,hashmap容量设置为17  ,即 7 &amp; (17-1)</span><br><span class="line">0000 1001    9</span><br><span class="line">0001 0000    16</span><br><span class="line">------------------</span><br><span class="line">0000 0000    0 索引位置为0</span><br></pre></td></tr></table></figure>

<p>由上面可以看出,当我们根据key的hash确定其在数组的位置时, 如果n为2的幂次方,可以保证数据的均匀插入,如果n不是2的幂次方,可能数组的一些位置永远不会插入数据,浪费数组的空间,加大hash冲突。因此,HashMap 容量为2次幂的原因,就是为了数据的的均匀分布,减少hash冲突,毕竟hash冲突越大, 代表数组中一个链的长度越大,这样的话会降低hashmap的性能</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p><strong>如果初始hashmap的容量不是2的n次幂,会做哪些操作</strong><br>如果创建HashMap对象时,输入的数组长度是17,不是2的幂,HashMap通过<code>移位运算</code>和<code>或运算</code>得到比那个数大且最近的二次幂数字。例如如果容量是17,初始化容量就是返回32</p>
<p>jdk1.8 表改变大小的源码操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给定目标容量的2次幂大小。  </span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再次强调一下：</p>
<blockquote>
<p><strong>按位与运算</strong> : 相同的二进制数位上,都是1的时候,结果为1,否则为零。</p>
</blockquote>
<blockquote>
<p><strong>按位或运算</strong> ： 相同的二进制数位上,都是0的时候,结果为0,否则为1。<br>1是负数  0正数</p>
</blockquote>
<p>下面看看这几个无符号右移操作是干什么的  </p>
<p><strong>第一种情况,容量传递的是0</strong></p>
<p>如果n这时为0了(经过了cap-1之后) , 则经过后面的几次无符号右移依然是0,最后返回的capacity是1 </p>
<p><strong>第二种情况,n不等于0</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HashMap &lt;String,Object&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">17</span>);</span><br><span class="line">cap = <span class="number">17</span></span><br><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span> = <span class="number">16</span>;</span><br><span class="line">第一次无符号右移一位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">0000</span>    n=<span class="number">16</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">1000</span>    n &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1000</span>    <span class="number">24</span> ===&gt;n</span><br><span class="line"></span><br><span class="line">第二次无符号右移<span class="number">2</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1000</span>    n=<span class="number">24</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0110</span>    n &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1110</span>    n = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">第三次无符号右移<span class="number">4</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1110</span>    n = <span class="number">30</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0001</span>    n &gt;&gt;&gt; <span class="number">4</span></span><br><span class="line">------------------------------------------------------ </span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n = <span class="number">31</span></span><br><span class="line"></span><br><span class="line">第四次无符号右移<span class="number">8</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>    n &gt;&gt;&gt; <span class="number">8</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line"></span><br><span class="line">第五次无符号右移<span class="number">16</span>位</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>    n &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0001</span> <span class="number">1111</span>    n=<span class="number">31</span></span><br><span class="line">执行最后一行代码操作,n&gt;<span class="number">0</span>且小于最大容量,返回<span class="number">31</span>+<span class="number">1</span> = <span class="number">32</span></span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>第三种情况Hashmap最大容量的移动位置操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">2</span>^<span class="number">30</span></span><br><span class="line"><span class="keyword">int</span> n = cap-<span class="number">1</span>;</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    n=<span class="number">2</span>^<span class="number">30</span> -<span class="number">1</span>   </span><br><span class="line"><span class="number">0000</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    n &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    n&gt;&gt;&gt;<span class="number">2</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">最后得到的值一定为</span><br><span class="line"><span class="number">0001</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>    <span class="number">2</span>^<span class="number">29</span></span><br><span class="line">加一操作后为</span><br><span class="line"><span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>    <span class="number">2</span>^<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong> ：如果容量大于MAXIMUM_CAPACITY  则取最大容量。不到2^30 的容量,通过移位操作后,会得到大于值的最小2的幂。如果当前值就是2的幂次方,返回当前值</p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p><strong>为什么Map桶中的节点个数要超过8才转红黑树</strong><br>因为树节点的大小大约是普通节点的两倍,所以我们只在链表中包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时,就会被转换回普通的桶。在使用分布良好的用户hashcode时,很少使用树箱。理想情况下,在随机哈希码下,箱子中节点的频率服从泊松分布,默认调整阈值为0.75,平均参数约为0.5,尽管由于调整粒度的差异很大。忽略方差,列表大小k的预期出现次数是(exp(-0.5)*pow(0.5,k)/factorial(k)).<br>     *<br>     * 0:    0.60653066<br>     * 1:    0.30326533<br>     * 2:    0.07581633<br>     * 3:    0.01263606<br>     * 4:    0.00157952<br>     * 5:    0.00015795<br>     * 6:    0.00001316<br>     * 7:    0.00000094<br>     * 8:    0.00000006<br>     * more: less than 1 in ten million<br>1.TreeNodes占用空间是普通Nodes的两倍,所以只有当链表中包含足够多的节点时才会转成TreeNodes,而是否足够多就是由TREEIFY_THRESHOLD（8）的值决定的。<br>当链表中节点数变少时, 红黑树又会转成普通的链表。并且我们查看源码的时候发现,链表长度达到8(桶的数量要大于64)就转成红黑树,当长度降到6就转成普通链表<br>这样就解释了为什么不是一开始就将其转换为TreeNodes, 而是需要一定节点数才转为TreeNodes, 说白了就是权衡,空间和时间的权衡。</p>
<p>2.当hashCode离散性很好的时候,树型节点用到的概率非常小,因为数据均匀分布在每个桶中,几乎不会有桶中链表长度会达到阈值。但是在随机hashCode下,离散性可能会变差,然而JDK又不能阻止用户实现这种不好的hash算法,因此就可能导致不均匀的数据分布。不过<strong>理想情况</strong>下随机hashCode算法下所有桶中节点的分布频率会遵循<strong>泊松分布</strong>,我们可以看到,一个桶中链表长度达到8个元素的概率为0.00000006. 几乎是不可能事件。所以,之所以选择8,不是随便决定的,而是根据概率统计决定的。</p>
<p>下面是我找的一个<code>泊松分布</code> 示意图<br><img src="https://ls-picture-oss.oss-cn-hangzhou.aliyuncs.com/Java%E5%9F%BA%E7%A1%80/HashMap/images/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83.png?versionId=CAEQGxiBgIDF.fqw2hciIGMxZjNiNzhmMDM0NzQyZjQ5OGE0MWY2OGM5MTg5MzZi"></p>
<p>图片原来链接：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html</a><br>可以参考看下</p>
<h4 id="问题4"><a href="#问题4：" class="headerlink" title="问题4："></a>问题4：</h4><p><strong>基于JDK1.8,hashmap引入了红黑树,为什么一开始不按照红黑树存储。非要等到链表长度大于8才转换</strong></p>
<p>1.JDK 1.8以前HashMap的实现是<code>数组+链表</code>,即使哈希函数取得再好,也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放到同一个桶中时,这个桶下有一条长长的链表, 这个时候HashMap就相当于一个单链表,假如单链表有n个元素,遍历的时间复杂度就是O(n),完全失去了它的优势。针对这种情况,JDK 1.8中引入了红黑树(查找时间复杂度为O(logn))来优化这个问题。当链表长度很小的时候, 即使遍历,速度也非常快,但是当链表长度不断变长,肯定会对查询性能有一定的影响, 所以才需要转成树。</p>
<p>2.TreeNodes占用空间是普通Nodes的两倍,当元素较少时,增加多余的开销</p>
<h4 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h4><p><strong>问题：为什么不使用AVL树而使用红黑树</strong><br>红黑树和AVL树都是最常用的平衡二叉搜索树，它们的查找、删除、修改都是O(lgn) time</p>
<p>AVL树和红黑树有几点比较和区别：<br>（1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。<br>（2）红黑树更适合于插入修改密集型任务。<br>（3）通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/21aspnet/article/details/88939297">https://blog.csdn.net/21aspnet/article/details/88939297</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后提供一个红黑树的学习地址,里面包含的各种数据结构,便于学习和理解数据结构<br><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://lswisdom.github.io/posts/221454777/" title="HashMap简单讲解" target="_blank" rel="external">https://lswisdom.github.io/posts/221454777/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/timg.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark"></span><small class="ml-1x">LsWisdom Blog</small></a></h3>
        <div>宝剑锋从磨砺出，梅花香自苦寒来</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/posts/221454721/" title="线程与并发基础"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/posts/2388768520/" title="红黑树"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lswisdom" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
    <script defer>
    var disqus_config = function () {
        
            this.page.url = 'https://lswisdom.github.io/posts/221454777/';
        
        this.page.identifier = 'JDK/HashMap简单讲解';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + '' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>








</body>
</html>